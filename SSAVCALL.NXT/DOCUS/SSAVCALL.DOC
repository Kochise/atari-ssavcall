/// STALLION SOFTWARE's AES/VDI CALLø Version 2.53 ////////////////////////////

CONVERTISEUR DE FORMAT D'APPELS A L'AES/VDI PAR STALLION SOFTWARE

PROGRAMMê PAR KOCH DAVID (IDFRAKOCH-9508851003894DAVID-7803118M5)
          EN ASSEMBLEUR 68030 AVEC DEVPAC V3.1 DE HISOFT
          SUR UN ATARI FALCON030 (Y44A02-4005369) 16Mo/540Meg/4xIDE/FP82

PREMIERE VERSION FONCTIONNELLE LE LUNDI 14 JUILLET 1997

THANKS TO : ATARI FOR THE FALCON, GREATEST COMPUTER OF THE WORLD
            MOTOROLA FOR THEIR POWERFULL 68000 CHIPS FAMILLY
            DIGITAL RESEARCH FOR THEIR FAILING BUT GOOD TOS 4.04
            HISOFT FOR THEIR EXCELLENT DEVPAC 3.1 AND DSP

/// ATTENTION /////////////////////////////////////////////////////////////////

SSAV est un Hexa_Ware, c'est Ö dire qu'il y a six faáons de s'enregistrer.
  ARTE_Ware, supporter audimatement la meilleure chaåne TV du monde et essayer
             de lui faire passer le cap des 4% d'audimat largement mÇritÇs
  Bugs_Ware, m'envoyer une liste de Bugs que VOUS avez trouvÇ
  Disk_Ware, m'envoyer une boite de 10 disquettes HD sans erreurs
  Info_Ware, m'envoyer des informations relatives Ö la programmation sur ATARI
  Prog_Ware, m'envoyer un programme de votre crÇation (utilisant ou non SSAV)
  SSAV_Ware, utiliser SSAV, tout simplement...

  Pour vous enregistrer, il faut que vous choisissiez au moins deux modes
diffÇrents parmi ceux de la liste prÇcÇdente. J'estime que ce n'est pas trop
demandÇ...
  Ceux qui m'envoie des informations sur le GEM afin que je corrige certains
dÇfauts de SSAV, je le considäre comme un enregistrement complet (Bugs_Ware et
Info_Ware).

/// Contacts //////////////////////////////////////////////////////////////////

Si vous voulez par exemples ajouter une fonction Ö la routine, reporter un bug,
me donner des informations sur le GEM (et MultiTOS surtout), me parler, bref,
me contacter, voici mon adresse :

KOCH David
29 Rue de GENEVE
85200 FONTENAY LE COMTE
FRANCE

et facultativement, ...
EUROPA (Allemagne, Belgique, Hollande, Italie, Luxembourg, Danemark, Irelande,
        Royaume Unis, Grece, Espagne, Portugal, Autriche, Finlande, Suede)
EARTH (North America, South America, Australia, Asia, Africa)
SOL (Mercure, Venus, Mars, Jupiter, Saturne, Uranus, Neptune, Pluton)
CORE SYSTEM (Proxima Centauri, Alpha Centauri, Barnard Star, Ross 154, Lalande
             21185, Lyuten 727-8, Sirius, Wolf 359, Ross 248, Epsilon Eridani,
             Ross 128, Luyten 789-6, Groombridge 34, Epsilon Indi, 61 Cygni,
             Sigma 2398, Tau Ceti, Procyon, Lacaille 9352, G 51-15, Van Maanen
             Star, Formalhaut, ...)
(Ces systämes solaires existent vÇritablement et ne font pas partis du dÇlire
 spatial de Sir BRABEN David, concepteur des fabuleux VIRUS (ZARCH sur
 Archimädes d'Acorn (Regardez l'Çmission du màme nom sur ARTE, elle est
 (presque) parfaite)) et FRONTIER)
VOIE LACTEE (Notre galaxie, c'est comme áa qu'elle s'appelle)
LOCAL GROUP (M 31 (Andromeda), M 33 (Triangulum), NGC 205, M 32, Leo 1, Leo 2,
             NGC 6503 (Draco), Ursa Minor, SMC (Tucuna), LMC (Dorado), NGC 253
             (Sculptor), NGC 1365 (Fornax), NGC 185, NGC 147, IC 1613, NGC 6822,
             ...)
...
                                          Kochise Of STALLION SOFTWARE

/// Doc Çcrite sur... /////////////////////////////////////////////////////////

Cette Çnorme documentation Ö ÇtÇ Çcrite sous le monstrueux 7UP V2.03f
(TheoSoft, Michael TÑnitz, francisÇ par LWING). Ch'u pas enrÇgistrÇ, mais áa va
pas tarder, car un soft aussi ergonomique pour Çcrire les docs, c'est pas
courant.

/// Merci pour leurs encouragements Ö... //////////////////////////////////////

A-HA (October, Cry Wolf, Maybe Maybe, Soft Rains Of April, The Swing Of Things)
BASSLINE BOYS (On se calme)
BELAFONTE Harry (Paradise In Gazankulu, Sisiwami, Skin 2 Skin, Global Carnival)
BLACK BOX (EveryBody, Ride On Time)
BROWN Bobby (On Your Own)
CAUET ("Je m'excuse")
CHERRY Neneh (7 Seconds, Mame Bamba)
CONFETTI'S (The Sound Of C, The House of C, Jingle Bells)
D.J. BOBO (There Is A Party)
EURYTHMIC (Missionary Man, A Little Of You, The Miracle Of Love)
FURYO (La B.O. du film du màme nom, avec BOWIE David (EKO, vot' DMO, pas pigÇ))
GENERATION DISCO (Generation Disco)
ICE Mc (Easy)
INNOCENTS (Les) (Un Homme Extraordinaire, L'autre Finistere, Fous Ö Lier)
JARRE Jean-Michel (Oxygen 5, EthniColor, Equinox, Rendez Vous)
LATINO PARTY (The Party, Tequila)
LILICUB (Voyage en Italie, J'ai croisÇ Ton Regard)
LORDS OF ACID (Voodoo-U, Marijuana In Your Brain, The Wet Dream, Dirty Willy)
MIND EVOLUTIONS (Trancelate, Quantum Beats, The Sun, NetWork 303, Pulstar)
M-PEOPLE (Moving On Up, Just For You)
OLDFIELD Mike ([Earth Moving], [QE2], [Crises], [Tubular Bells])
PUBLIC ENEMY (Give It Up, I Ain't Mad At All, Stop In The Name, Hitler Day)
SASH (Encore Une Fois, Oxygen 10, Ecuador)
S-EXPRESS (The Theme)
SNAP (The Power, Rythm Is A Dancer, Cult Of Snap, The First The Last Eternity)
SNOW Marc (X-Files Theme)
SPAWN (La B.O. du film du màme nom)
SPICE GIRLS (Wanna Be, Bumper To Bumper)
SPIN DOCTORS (Two Princes, Off My Line)
TECHNOTRONIC (Pump Up The Jam)
et tous les autres, insignifiants ou moins (Bjork, France Gall, Treponem Pal,
OffSpring, etc...) qui passent en fond sonore, mais que je n'oublie pas pour
autant.

/// Je recherche... ///////////////////////////////////////////////////////////

Appel Ö l'AIDE : - J'ai besoin de toutes les informations possible
                   (HardWare et SoftWare) sur : 68020, 68030, 68040, 68060,
                   68881/2, 6800/2/9, 6502, DSP 56000/1/2, DSP 96000/1/2,
                   8086/7,8, 80186/7, 80188, 80286/7, 80386/7, 80486, 80586,
                   80686, PowerPC, ColdFire.
                 - Toutes les informations possible sur la programmation de
                   TOUS les ATARI (du ST au Falcon030, en passant par le TT, le
                   Stacy, le STBook, l'ATW800, les ABC, le PortFolio, les VCS
                   2600, 5200, 7800, Lynx, Panther (si quelqu'un a quelque
                   chose dessus), Jaguar, et autres si j'en oublie...

/// Bibliographie /////////////////////////////////////////////////////////////

CLEFS POUR ATARI ST Tome 2 "GEM" par MARTIN Daniel aux Editions du P.S.I.
 ISBN 2-86595-374-2 CodBar 9-782865-953745 1986
GEM FöR DEN ATARI 520 ST par STEINER Joseph et Gerhard Ö Markt&Technik
 ISBN 3-89090-230-8 CodBar 4-001057-902305 1985-1986
DEVELOPPER EN GFA BASIC par l'auteur OSTROWSKI Frank Ö Micro Application
 ISBN 2-86899-103-3 CodBar X-XXXXXX-XXXXXX ISSN 0980-1928 Code 281 Ref ML295
LE LIVRE DU DEVELOPPEUR TOME 1 aux Editions Micro Application
 ISBN 2-86899-402-4 CodBar 9-782868-994028 ISSN 0980-1928
ASSEMBLEUR 68000 DE L'ATARI ST par HARD Olivier Ö Cedic/Nathan
 ISBN 2-86699-527-9 CodBar 9-782866-995270
AES LIBRARY & VDI LIBRARY par HiSoft
 ISBN 0-948517-59-X CodBar 5-024100-000192 1988-1992
PowerPC - Microprocessor Developer's Guide chez SAMS PUBLISHING (USA)
 ISBN 0-672-30543-7 CodBar 9-780672-305436 90000

De nombreux articles sur la chose parus dans ATARI Magazine, Start Micro
Magazine, et ST Magazine.

De träs nombreuses explications de Maitre ATTARD, gÇnie en la matiere,
concepteur de BIG, une bibliotheque de gestion d'interface, en C, elle.

/// Pourquoi SSAVCALL /////////////////////////////////////////////////////////

  C'est une longue histoire, dont je ne vous conterais pas en dÇtail les
tribulations. Cependant, lecteur, lectrice, sachez que ce fut dur et difficile
d'obtenir ce rÇsultat, tout cela Ö cause de...

  J'ai, malgrÇ mon petit moignon de vie dÇjÖ bien entamÇe, une experience des
ordinateurs assez importante. Mon premier, je me souvient, me fut donnÇ en
1887, erreur: 1987. Ce fut un Vic20 de Commodore, le grand fräre du C64. Ha le
pied, interprÇteur Basic, 4Ko de mÇmoire, lecteur de cassettes, une tÇlÇ N/B
comme Çcran... Bref, une aventure succulente. Mon suivant, qui ne m'appartenait
pas, mais que j'utilisait abusivement chez un ami, fut un CPC6128. Une
rÇvolution, pensez: Çcran couleur, lecteur de disquette double face (qu'il
fallait retourner comme une cassette pour acceder Ö l'autre face),
imprimante... Spectaculaire. C'est ici que je commenáa rÇellement Ö programmer.
Oh pas grand chose, quelques shell, ainsi qu'un tout petit jeu en Basic, sans
utiliser les possibilitÇes de la machine via de nombreux POKEs. Je m'en
souvient, ces heures qu'on pouvait passer devant, jouant Ö BoulderDash ou Bob
Winner. Fabuleux. Puis, mon cousin me prÇsenta l'opportunitÇ de m'acheter un
1040 STf. J'avais bien un ou deux (pour leur malheur) copains qui en disposait
aussi. Aussi, je decida d'acquerir cette machine de reve, en 1990. Je n'en
avait jamais rÇellement entendu parler de cette machine, seulement jouer
occasionellement dessus. En ces temps reculÇs, je la voyait comme ultime. 1Mo,
lecteur double densitÇ, Çcran monochrome (la couleur me vint bien plus tard
hÇlas), pas de problemes de configuration. Au dÇbut, j'avoue, mon activitÇ
premiere fut le jeu. J'y repense maintenant, toutes ces disquettes
d'utilitaires que j'ai effacÇes pour y mettre des jeux. Je me dÇgoute rien que
d'y penser. Bweark, des jeux, ces oeuvres stÇriles rapidement vaincus par la
sagacitÇ d'un joueur tenace. J'ai perdu deux, non, trois ans avant de revenir Ö
la programmation. Trois ans oó j'ai vÇgÇtÇ, glandÇ, rien branlÇ...
  Puis le dÇclic, je ne sais pourquoi... En fait si. Le prÇcÇdent maitre de mon
1040 ne m'avais pas refilÇ la disquette du GFA, mais le bouquin oui. Ce n'est
seulement qu'apräs une pÇriode d'ennui profond, et de besoin de nouveautÇs que
je me procura sans peine une copie du GFA chez un copain, contre deux jeux. Et
c'est Ö partir de lÖ que tout dÇmarra. Au dÇbut, ce ne fut pas joyeux. Mes
souvenirs avaient ternis, et ma faible expÇrience c'Çtait envolÇe. De plus,
manquant cruellement de documents pour une machine aussi complete, j'eus
beaucoup de difficulter Ö en maitriser les arcanes. Je fis bon nombres
d'erreurs, qui aujourd'hui m'ont ÇtÇs bÇnÇfiques. Mais j'Çtait seul.
Fini la communion par le jeu. J'Çtait vu un peu comme une bete Çtrange Ö
chercher la maitrise de mon engin manuellement (n'ayez donc pas toujours les
idÇes mal placÇes). Ce n'est que plus tard, au bout de deux ans, Ö l'aube
naissante de l'acquisition de mon Falcon030 apräs le premier ATARI Show de
Levallois-Perret en 1995 (merci Joel) que deux de mes amis se mirent Ö la
programmation. Ils firent en GFA un jeu qui aurait mÇritÇ la diffision. Mais il
n'abouti hÇlas jamais. C'est aussi un peu avant ce moment lÖ que j'entra en
possetion d'un 130XE, que je garde uniquement par collection.
  Vint enfin le Falcon030. Apräs un passage Ö TurtleBay, j'eus donc chez moi
ce drole d'oiseau, que j'eus un peu de mal Ö apprivoiser. Un disque dur mes
amis. Pas croyable. On y goute, et l'on se demande comment on fesait avant. Oh
vous savez, j'Çtait organisÇ. Dans ma boite, deux rangÇs de disquettes. L'une
contenant les divers programmes, l'autres les donnÇes correspondantes. Je
piochait dans la promiere rangÇe, puis le chargement effectuÇ, dans la seconde.
Les chargement long et bruyants s'eternisaient parfois, me laissant souvent le
temps d'aller faire mes besoins. Mais maintenant, je crains les calculs ou un
cancer de la prostate par une retention prolongÇe. N'y voyez rien de scato,
c'est juste pour vous faire imaginer le boulversement subi dans ma facon de
travailler avec ma machine. N'ayant jamais utiliser XControl, j'avais un peu de
mal. Oó regle t'on le son? Bref, un temps d'adapation fut necessaire, alors que
je l'avais esperÇ nul car successeur du ST.
  A prÇsent, j'ai une configuration d'une stabilitÇ affligeante. Rien ne
plante, sauf si on le cherche. NE METTEZ JAMAIS SNAPSHOT (de Dieter Fiebelkorn)
ET CLOGGE ENSEMBLE. C'est Ö partir de lÖ que je me lanáa timidement, mais non
sans espoir, Ö l'assembleur. J'eus beaucoup de difficultÇs, car cela n'est pas
evident de passer d'un langage oó l'on se fout totalement de savoir comment le
processeur fonctionne, du moment oó l'on Ö quelque chose Ö l'Çcran apräs un
PRINT, Ö un langage oó il faut dire au processeur ce qu'il doit faire, pas Ö
pas, jusqu'au rÇsultat escomptÇ. Les docs techniques ne sont pas tutoriales
pour les neophytes, et la pseudo initiation reprise plusieurs fois par ST Mag
(surtout celle Ö partir du n¯63) n'Çtait pas ce qu'il existait de plus clair.
Jusqu'au jours oó Start Micro et son SÇbastien ROHAUT eu l'intelligence de se
pencher sur le probleme. Ah miracle, quelqu'un savait expliquer comment faire.
La brume nÇbuleuse se dissipa progressivement, et j'entrevoyait dÇjÖ de future
production fabuleuses. Mais un obstacle fut de taille. L'interface...
  En GFA, j'avais fait un petit noyau que je rÇutilisait rÇgulierement, un
noyau qui me donnait autant de libertÇ qu'une interface textuelle sous DOS sur
PC. On se dÇplacait avec les fleche, et la position actuelle etait mise en
video inverse. Mais j'eus la mauvaise idÇe de me pencher sur l'autre, cette
fabuleuse
interface que j'utilisait quotidiennement, le GEM. J'acheta mon premier livre,
et j'eus la nausÇe. J'eus l'impression de revenir quelques annÇes en arrieres,
du temps oó je ne savais rien de l'assembleur, et que je tombait rÇgulierement
sur des ouvrages indigestes, juste bon Ö servir d'aide mÇmoire, mais jamais
rien d'educatif. Horreur rÇsumait ma situation. Cela semblait compliquÇ, hors
de portÇ, et limitÇ au langage C. Comment m'en sortir, une question que mon
esprit se faisait un plaisir de ressacer continuellement, me plongeant dans une
torpeur intellectuelle indescriptible. Mais j'en avait vu d'autres, et je me
souvint alors de mes efforts pour maitriser l'assembleur. Et je trouva en la
personne de Maitre ATTARD celle qui me demystifia le GEM comme Maitre ROHAUT
avait su le faire pour l'assembleur. Et je compris...
  Trop bien a mon grand regret. Non que cela fut hors de portÇ comme je l'avais
dabord cru, mais plutot reservÇ au C. Je vais tacher de vous exposer le
probleme sans etre, je l'espere, soporifique. Pour programmer, en Basic par
exemple, vous utiliser une instruction comme PRINT, mais qui en reprÇsente
plusieurs en assembleur. Ces instructions en code machine vont indiquer au
processeur comment faire progressivement pour afficher le texte Ö l'Çcran. Ce
texte, c'est une suite d'octets dont chaq'un reprÇsentes une lettre. Pour cela,
il va falloir acceder Ö l'Çcran, et y envoyer le texte dÇsirÇ. Mais cela n'est
pas simple. Chaque programme peut s'en occuper, Ö la main, comme beaucoup font
sur PC pour eviter d'avoir Ö payer les royalties pour utilisations des
bibliotheques copyrightÇes de Borland ou autres (ce qui explique la taille
parfois hilarante de certains programme). Mais une solutions consiste Ö ecrire
des routines que l'on met Ö disposition de tout Ö chaqu'un via le systeme
d'exploitation. Celui ci, c'est le GEM, le GEMDOS, le BIOS ou l'XBIOS. Toutes
ces routines sont ecrites une fois pour toutes, et chaque programmeur peu les
utiliser. Cela rÇduit la taille des programmes, ainsi que le temps de
programmation. Voyez, pour ecrire quelque chose Ö l'Çcran, il faut utiliser le
matÇriel de la machine Ö un niveau träs bas. Pour cela, l'assembleur est
utilisÇ. Oó je veut en venir, c'est que lorsqu'on dialogue avec le GEMDOS, le
BIOS ou l'XBIOS, vous empilez les informations dans un certains ordre, puis
faites un TRAP. Le TOS se dÇbrouille, et rÇutilise les donnÇes que l'on lui Ö
fournit. En retour, votre texte Ö l'ecran. Et votre petite amis de siffler
d'admiration devant votre excellence...
  Mais y'a un os (O.S.). Le GEM se "contente" de GERER une interface, et ne
fait pas
appel Ö la machine (sauf pour dessiner l'interface). Or cela aurait demandÇ un
travail titanesque Ö faire en assembleur, et la couille dans l'histoire, c'est
justement que le GEM Ö ÇtÇ Çcrit en C, pour faciliter la tache de Digital
Research, mais pas la notre. Oh, les programmeur en C n'en ont rien Ö foutre de
nos problemes. Voyez vous, oó dans l'autre partie du TOS, ecrite en assembleur
pour coller de pret Ö la machine, il fallait simplement empiler les infos et
TRAPer, ici, il faut faire des petits tableaux, c'est Ö dire des successions de
deux octets, dans lesquels vous metterez vos informations, ou lirez. L'os,
c'est qu'en assembleur 68000, c'est hyper chier de faire áa, et les programmeur
en C de s'exclafer, et d'en profiter pour vanter leur langage fÇtiche Ö juste
titre (n'est ce pas Mr ATTARD). Le 68030 a ÇtÇ concu en tenant compte du fait
que le C est tres utilisÇ de part le monde, et propose de spendides modes
d'adressages qui nous mettent Ö ÇgalitÇ avec les utilisateurs de C (merci
Motorola de votre clairvoyance). Mais lÖ encore, faut toujours s'occuper de ces
fichus tableaux hÇritÇs du C, màme si cela est plus convivial avec les nouveaux
modes d'adressages. C'est enfin lÖ que vous allez savoir Ö quoi sert SSAVCALL.
  En fait, c'est une sorte de convertisseur d'appel. Vous empilez les infos,
appelez SSAVCALL, et c'est lui qui va ENTIEREMENT s'occuper de ces tableaux,
les remplir, ou vous retourner le rÇsultat dans un registre. Oh, certains (bien
connus et mÇdiatisÇs) n'y voient "AUCUN INTERET". Mais IMAGINEZ le gain de
temps, n'ayant plus Ö vous occuper des tableaux, mais juste Ö empiler,
basiquement. NON, il n'y a pas de triche, le GEM fonctionne ENCORE avec des
tableaux, votre programme doit toujours en avoir sous la main, mais CE N'EST
PLUS A VOUS DE VOUS EN OCCUPER. Evidement, on aurait pus y songer plus tot, le
principe est simple Ö chialer, mais voila, c'etait peut etre trop simple, ou
alors "vraiment sans interet" (n'est ce pas Centek). Bref, SSAVCALL rend de
fier services sans manger beaucoup de pain.
  Dans les premiers versions, SSAVCALL n'occupait que 25Ko bien tassÇs, Çtait
relativement simple (uniquement conversion). Mais il s'avera qu'a chaque
programme, j'avais toujours les boites de dialogue Ö gerer, les menus, et
autres... Et puis surtout, Stabylo en sait quelque chose, les chiffres Ö
convertir. En Basic, l'interpreteur dispose de routines de convertions, mais en
assembleur, c'est l'enfer pour afficher de facon lisible un chiffre flottant
(arg, toutes ces soirÇe Ö chercher comment faire). N'y tenant plus, tout áa
c'est dans SSAVCALL.
  Les changements majeurs par rapport aux premieres versions, c'est donc dÇjÖ
cette fonction de convertion numÇrique (380 routines), des bibliotheques
integrÇes de gestion d'interface, mais avant tout, un nouveau style de
programmation. Les premieres versions n'Çtaient pas optimisÇe; màme pas
seulement pour faciliter la recherche des bugs, mais parce que mon experience
n'avais pas encore atteinte mon niveau actuel. J'ai bien commencÇ un
generateur de montagnes fractales pour NeoN (t'en pense quoi Stabylo?), un
driver de disque dur incluant driver de cdrom et utilitaires Ö la checkdisk, un
pseudo Basic melant assembleur dans le genre modula 2, une routine 3d au copro,
et divers trucs, mais mon experience SSAVCALL m'a permise de m'amÇliorer
considÇrablement, surtout avec ma politique de programmation.
  En effet, lorsque je ne suit pas fier de quelque chose, je l'efface sans
remors, màme si j'y ais passÇ deux mois. Je veux oublier les erreurs, n'ont pas
pour les refaire, en fait je les connait, mais pour eviter de les reutiliser
par fleme, en repompant des truc pas clean. De nature assez maniaque, je
deteste les progs mal concu. Cela vient en outre du fait d'avoir programmÇ sous
GFA, qui permet de structurer ses programmes comme seul le GFA est capable de
le faire (procedures enroulables essentiellement). Aussi, cette habitude, je
l'ai
gardÇe en assembleur, et je ne crains pas d'avoir Ö reprendre deux mois de
boulot (habituÇ que je suis de perdre mon disque dur lorsque je teste mon
driver). Cela me permet Ö chaque fois de m'essayer dans un autre style, et de
dÇcouvrir de nouvelles facons de travailler, me permettant de gagner du temps
ou
de l'espace, voire de rendre un source assembleur plus comprehensible (le pied
quoi...).
  SSAVCALL, dans sa version 2, bÇnÇficie donc d'atout important. Une
programmation irrÇprochable, une vitesse d'execution imbattable par
l'utilisation des modes d'adressages du 68030, une profusion de routines toutes
plus utiles les unes que les autres. Bref du grand art. NON, je ne suis pas
modeste, comme vous pouvez le lire. Je sais que SSAVCALL est un grand projet,
et je refuse la fausse modestie qui ne vise qu'Ö s'attirer les compliments
d'une foule subjugÇe par votre crÇation. Si vous avez fait quelque chose de
gÇnial, reconnaissez le, un point c'est tout, et epargnez moi "on en sait
quelque chose du GEM, et tant que crÇateur (repompeur) d'OS, alors ton truc,
c'est VRAIMENT SANS INTERET". Je cire les pompes ou pas?
  Actuellement, je suis a l'ecoute de toute proposition CONSTRUCTIVE. Apres
tout, SSAVCALL est avant tout (Apres? Avant?) Ö votre service. S'il y a
quelque chose Ö corriger, modifier, ajouter (pas retrancher, comme CALLM, n'est
ce pas Mr CONTER), faites le moi savoir, par pitie. Mais de toute maniere,
SSAVCALL va evoluer, car s'il existe, c'est comme chaque fois et pour chaque
programmeur, Ö cause d'un besoin personnel. Tous les programmes ayant un but
purement commercial ne valent rien, car n'ayant pas ete concu de facon
ergonomique pour repondre Ö un besoin. L'OS (c'est le cas de le dire) principal
du PC en est la meilleur
preuve. Bien qu'il soit parmis les plus mauvais, coute une fortune (deguisÇe
aux yeux du consommateur), qu'il existe des alternatives stables et gratuite
(Linux par exemple), ou commerciale comme QNX, il s'est rÇpandu tout autant que
son moulin Ö cafÇ de support. Mais bon, je ne vais pas m'en plaindre, du moment
qu'on nous foute la paix, et que l'on n'essaye pas de venir veroler le fragile
monde ATARI avec des merdes de ce genre. C'est entre autre pour cela que le
68030 Ö put se permettre de ne plus etre totalement compatible avec le 68000
(ah oui? le Pentium est compatible avec le 8086? Pourtant mes anciens softs ne
marchent plus, et les societes sont tout de màme obligÇes d'acheter les mises Ö
jour, malgrÇ que l'on leur ait fait miroiter la possibilitÇ de reutiliser leurs
anciennes acquisitions, alors que sur mon Falcon030, j'utilise sans probleme
parmis les premiers softs du ST),
et d'adopter des revolutions comme les modes d'adressages genre C, ou autre.
Motorola n'est TELLEMENT PAS PRISONIER de son succes, qu'il se permet le loisir
de revoir sa copie, et de clore la famille 68000 pour pondre le ColdFire, un
Risc Ö 68000 transistors qui fait presque aussi bien qu'un 68040 Ö frÇquence
Çgale, pour 50 fois moins cher. Gniark...
  Mais bon, je m'egare, et tout cela n'est qu'affaire de gout. Y'a ceux qui,
intelligent, savent utiliser des outils de bonne facture, ou d'autres qui pour
rompre leur sollitude utilise l'alibi d'avoir un PC et d'organiser des
colloques pour mieux apprendre Ö savoir dÇjouer les pieges afin de ne pas
planter
des le premier fremissement de souris, ou lancer un soft de 576Ko sous DOS.
Marrant, j'ai une archive pondu via STZIP, autoextractable, 11Mo, et pas de
probleme. Pourtant mon Falcon ne coute que 5 fois moins cher que leurs daubes
(donc aussi 5 fois moins de souáis). Mais il me semble qu'il faille de tout
pour faire le monde, meme des masos.
  Bref, je ne vais pas m'etaler d'avantage sur une documentation par dÇjÖ trop
imposante. Sachez qu'ici vous trouverez, EXPLIQUE par quelqu'un de competent en
la matiere (Ö prÇsent), les informations les plus
prÇcises jamais diffusÇes (je l'espere, mais en tant qu'homme, je ne suis pas Ö
l'abri d'une ou
deux erreurs). Je ne me suis pas contentÇ de traduire la doc d'ATARI, mais bien
de rechercher comment faire dÇcouvrir le GEM Ö un nÇophyte, tout en Çtant
prÇcis. Aussi, bon trip, et sachez exploiter
correctement SSAVCALL. Respectez les conseils, SVP, il en va de l'evolutivitÇ
du systeme. Sur ces bonnes paroles, bon amusement...

/// Philosophie du GEM ////////////////////////////////////////////////////////

  Je vais (peut etre Ö votre grand regret), introduire le GEM, et sa faáon de
l'aborder. J'eviterais aussi un titre du genre "le GEM pour le nul" et
d'arborer avec une fiertÇe non dÇguisÇe le nombre de nuls me lisant. Ca me
dÇprime de le savoir. Et puis le but est que vous ne le soyez plus, alors bon,
soit, un bon titre, flatteur, serait "le GEM pour les Dieux".
  Alors? Qu'en pense votre ego? C'est y pas mieux comme áa? Non non, ce n'est
pas une pub mensongere. Une fois arrivÇ Ö la fin de ce bouquin, vous serez des
dieux du GEM. Je ne garanti pas la mÇthode, mais j'ai confiance en moi. C'est
dÇjÖ un bon dÇbut. Bien, allons z'y...
  Peut etre vous aussi avez construit un programme avec son interface sous TOS,
n'ayant pas le savoir (nul n'est omniscient) d'utiliser le GEM. Vous aussi avez
peut etre pestÇ contre ces fichus editeur qui espere que vous achetiez toute la
serie sur le GEM pour que vous finissiez par vous rendre compte que vous n'etes
en fait pas plus avancÇ. De traduction gerbatoire Ö fausse explications, on
navigue entre deux eaux, et pas les meilleures. Meme certaines docs issuent
d'ATARI ne sont pas totalement fiables. Bref, le pied. Et il est vrai que
lorsqu'on aborde le GEM, c'est aussi difficile que lorsque l'on aborde
l'assembleur. Mais soyez courageux, vous verrez, vous en viendrez meme plus
vite Ö bout.
  Sous TOS, lorsque vous concevez votre interface, vous associez un ecran Ö une
procedure. Par exemple, le programme FICHIERS. Page d'acceuil, une liste de
numÇro. C'est une procedure qui attent de vous d'entrer un numÇro pour executer
la procedure correspondante. Vous avez peut etre fait plus elaborÇ, et lÖ vous
vous dÇplacez avec les fleches. Le rÇsultat au fond est le meme. Mais
regardons de plus pret ce que vous avez fait.
  Vous avez fait une sorte de procedure qui rÇagie suivant le bon vouloir de
l'utilisateur. Cette procedure renvoie un rÇsultat suivant le choix fait. Tout
ceci ressemble Çnormement au GEM, sachez le. Mais la grande diffÇrence, c'est
qu'ici, vous vous etes occupÇ des deux aspect de votre programme. L'interface,
et la partie qui travaille dans l'ombre. Aussi, afin de vous eviter une prise
de tete inutile, vous avez limite les procedure Ö ce qui est strictement
necessaire, sans chercher Ö en faire plus. Bravo, vous avez pondu un code
optimisÇ. SÇrieusement, c'est du bon boulot, vous savez subvenir Ö vos besoin.
Mais il se trouve, ce n'est pas du tout un reproche, que votre interface colle
exactement Ö votre programme. Celle ci Ö ÇtÇ taillÇe sur mesure pour
l'utilisation que vous voulez en faire. Et vous l'avez programmÇe du meme
accabit que le reste, sachant ce que vous desiriez. Or en GEM, c'est presque
totalement diffÇrent.
  D'une certaine maniere, ce n'est plus vous qui vous occupez de l'interface.
Je m'explique. Le GEM Ö ÇtÇ concu pour rÇpondre Ö tout les cas de figure,
malgrÇ les lacunes que l'on lui connait (SSAVCALL sert entre autre Ö les
combler). Des plus simples aux plus exigentes, le GEM doit servir Ö tout, mais
surtout Ö TOUS. Aussi, le GEM est une sorte d'interlocuteur avec lequel on
dialogue en rÇsaux. Ne vous attendez pas Ö voir un jour sa tete, mais sachez
qu'il s'occupe de toute la gestion de l'interface. Il vous reste juste Ö
programmer la rÇaction de VOTRE PROGRAMME par rapport aux diffÇrents evenements
qui se produisent sur l'interface. Justement, le GEM ne fonctionne qu'avec des
evenement. Vous avez une fenetre ouverte sur le bureau (mais oui, vous y
arriverez un jour, ne deseperez donc pas), et vous, ou un utilisateur, cliquez
sur le bouton de fermeture. Tout cela, ce n'est pas Ö vous de vous en occuper,
le GEM le fait. Cependant, il faudra prÇvoir dans votre programme une rÇaction
au cas oó Mr GEM vous contacte pour vous apprendre que l'on Ö cliquez sur le
bouton de fermeture de telle ou telle fenetre. A vous de savoir ce que vous
comptez en faire, de la fenetre. Car elle ne se ferme pas toute seule. Imaginez
que dans cette fenetre il y ait un texte. Vous fermez, certe, mais il faut
dabord demander Ö l'utilisateur s'il veut sauver son texte, l'abandonner, ou
continuer Ö Çcrire. Vous verrez, le GEM est un Monsieur träs polit, träs träs
compÇtent, qui fait du träs bon travail, mais qui ne fait pas le programme Ö
votre place. Mais n'ayez pas peur. D'utiliser cette interface toute prete est
vraiment formidable, car elle l'est tout autant, vous verrez...
  Mais avant de voir ce que peut faire SSAVCALL dans ce sens, on va dÇjÖ
aprendre ensemble Ö se servir du GEM comme tout le monde l'a fait jusque lÖ,
juste en empilant simplement au lieu de s'amuser Ö remplir des tableaux (alors,
le tableau INT_IN, il se trouve oó dÇjÖ? INT_IN2, c'est donc 6 octets apräs, et
l'adresses du dÇbut du tableau Int_In est contenu 8 octets apräs le dÇbut du
tableau Params... Petit dÇlire histoire de vous faire peur). Mais cela
n'empeche pas de vous expliquer comment áa marche sans SSAVCALL. Vous
comprendrez ainsi mieux ses avantages.

/// Plusieurs choses, ... /////////////////////////////////////////////////////

  Evidement, si vous utilisez cette routine dans un de vos programmes, ce serait
cool Ö vous de l'indiquer quelque part dans votre interface. Merci encore...
  Lorsque j'installe SSAVCALL en mÇmoire (donc ne pas l'inclure dans votre
code), j'installe un Cookie du doux nom de "SSAV". Son information (les quatre
octets suivant le nom du Cookie) n'est autre que l'adresse de la routine (la
routine, et pas les octets d'informations). Utilisez une Çtiquette oó vous
stockerez son adresse. Comme la routine n'est pas elle-màme multi-tache,
chaqu'une (des tÉches) doit avoir ses propres variables d'Çchange avec le GEM
(voir UTILSSAV.S, qu'il fait bon inclure, par contre, dans vos programmes).
  Je voudrait aussi demander Ö ceux qui ont, qui font, ou qui vont faire des
interfaces sous GEM de ne pas trop travailler dans leurs coins. Il serait bon
qu'il existe une sorte de "standard esthÇtique" pour homogÇnÇiser l'aspect du
GEM suivant le programme. Il est Çvident que chacun essaye de se dÇmarquer par
tous les moyens possibles son programme d'un autre, mais de l'extÇrieur, pour
quelqu'un habituÇ Ö travailler sous WinDaube ou System 7 et leurs interfaces
aseptisÇes, c'est le fouillis et le bordel le plus total, oó une impression
d'anarchie et de non dialogue rägne sur ATARI (peu àtre une cause de la mauvaise
image que l'ont portes comme un terrible PC..., pardon, fardeau). Je ne vous
demande pas de suivre mon style d'interface, quoique j'essaye de le rendre le
plus agrÇable possible pour l'oeil.
  Bien, Ö vous les programmeurs...

/// Le GEM, comment áa marche ////////////////////////////////////////////////

  N'etant pas Ö l'abri de l'effet bonaldi, il sagit d'avancer prudement. Comme
promis donc, je vais vous compter comment dans des temps tres anciens les sages
utilisaient le GEM.
  Donc pour le GEMDOS, le BIOS ou l'XBIOS, vous empilez les infos, puis
terminez par le numÇro de la fonction. Le numÇro du TRAP dÇtermine lequel du
GEMDOS, Bios ou XBIOS (1, 13, 14 respectivement) vous voulez.
  L'AES et le VDI se trouvent tous les deux au TRAP 2.

Bon, je vous avait parlÇ de tableaux. Le premier s'appelle Params. Il rÇunit
dans UN CERTAIN ORDRE les adresses des autres tableaux. Il existe deux tableaux
Params, l'un pour l'AES, l'autre pour la VDI.

Tableau AES_Params : LONG 0 - Adresse du tableau Control
                     LONG 1 - Adresse du tableau Global
                     LONG 2 - Adresse du tableau Int_In
                     LONG 3 - Adresse du tableau Int_Out
                     LONG 4 - Adresse du tableau Addr_In
                     LONG 5 - Adresse du tableau Addr_Out

Tableau VDI_Params : LONG 0 - Adresse du tableau Contrl
                     LONG 1 - Adresse du tableau Intin
                     LONG 2 - Adresse du tableau Ptsin
                     LONG 3 - Adresse du tableau Intout
                     LONG 4 - Adresse du tableau Ptsout

ATTENTION: Pour l'AES, la structure du tableau est In, Out, In, Out
                  VDI                              In, In, Out, Out
           Ce n'est pas une erreur de ma part.

Comme vous pouvez le voir, les deux tableaux Params sont lÇgerements
diffÇrents. Pour l'installation, rÇutilisez le fichier IVx-SSAV.S. Il contient
le dÇmarrage d'un programme et l'installation des diffÇrents pointeurs.
Voyons maintenant les diffÇrents tableaux, et leur utilisation.
Chaque ÇlÇments des tableaux fait un WORD.

--- Les tableaux de l'AES ---

Tableau Control : Ce tableau sert Ö indiquer Ö l'AES le nombre de parametres Ö
Longueur 5 WORDS  utiliser.
                  WORD 0 - Control0 : NumÇro de la fonction AES. C'est ici que
                                      l'on la met, et pas l'empiler en dernier
                                      comme dans les fonctions du GEMDOS, BIOS
                                      ou autre XBIOS.
                  WORD 1 - Control1 : Nombre de WORDs Int_In Ö utiliser.
                  WORD 2 - Control2 : Nombre de WORDs Int_Out en sortie.
                  WORD 3 - Control3 : Nombre de LONGs Addr_In Ö utiliser.
                  WORD 4 - Control4 : Nombre de LONGs Addr_Out sortie.

ATTENTION: Les nombres de parametres Out, comme Int_Out ou Addr_Out ne sont pas
           donnÇes
           par l'AES. Ce sont le nombre de rÇponses que l'AES doit vous
           envoyer. Si vous mettez 0 dans Control2, vous n'aurez pas de rÇponse
           de l'AES. Si la doc d'ATARI vous dit de mettre 2, pour avoir deux
           rÇponses, dans Int_Out0 et Int_Out1, mettez 2 comme demandÇ dans
           Control2. C'est extremement important, et c'est une cause de
           nombreuses erreures.
           Certaines docs indiquent que Control2 et Control4 sont donnÇs en
           retour, pour savoir combien de rÇponse envoie l'AES. C'EST
           TOTALEMENT FAUX. Il faut mettre ces nombres AVANT d'appeler l'AES.

Tableau Global   : Ce tableau sert Ö obtenir divers renseignements sur le GEM
Longueur 15 WORDs  et le systeme d'exploitation.
                   WORD 0 - Global0 : Ap_Version : Version de l'AES utilisÇ
                   WORD 1 - Global1 : Ap_Count : Nombre d'application pouvant
                                                 etre executÇes simultanÇment.
                                                 UtilisÇ avec les systemes
                                                 multitaches.
                   WORD 2 - Global2 : Ap_ID : Le numÇro obtenu apräs APPL_INIT.
                   LONG 3 - Global3-4 : Ap_Private : Peu vous servir, mais ne
                                                     sert pas Ö l'AES.
                   LONG 5 - Global5-6 : Ap-PTree : Adresse de la ressource
                                                   apräs un RSCS_LOAD.
                   LONG 7 - Global7-8 : Ap_1Resv : RÇservÇ
                   LONG 9 - Global9-A : Ap_2Resv : RÇservÇ
                   LONG B - GlobalB-C : Ap_3Resv : RÇservÇ
                   LONG D - GlobalD-E : Ap_4Resv : RÇservÇ

Tableau Int_In   : Ce tableau sert Ö dialoguer directement avec l'AES. Vous y
Longueur 16 WORDs  passez les parametres utilisÇs par les fonctions. N'oubliez
                   pas d'indiquer dans Control1 combien de parametres il doit
                   utiliser.

Tableau Int_Out  : Ce tableau permet Ö l'AES de vous rÇpondre. C'est ici
Longueur 8 WORDs   que vous obtenez les rÇsultats.

Tableau Addr_In  : Ce tableau sert Ö donner des adresses Ö l'AES. DÇpend de la
Longueur 3 LONGs   fonction. N'oubliez pas d'indiquer combien d'adresses
                   utiliser dans Control3.

Tableau Addr_Out : Ce tableau, composÇ d'un seul ÇlÇment, permet Ö l'AES de
Longueur 1 LONG    vous donner une adresse.

--- Les tableaux du VDI ---

Tableau Contrl   : Ce tableau remplit la meme fonction que le tableau Control
Longueur 12 WORDs  de l'AES. Il permet d'indiquer au VDI ce que l'on lui veut.
                   WORD 0 - Contrl0 : NumÇro de la fonction VDI.
                   WORD 1 - Contrl1 : Nombre de couples PstIn Ö utiliser.
                   WORD 2 - Contrl2 : Nombre de couples PtsOut en sortie.
                   WORD 3 - Contrl3 : Nombre de LONGs IntIn Ö utiliser.
                   WORD 4 - Contrl4 : Nombre de LONGs IntOut sortis.

Ici, les longueur des tableaux ne sont pas fixes, ATTENTION.

Tableau IntIn    : Meme utilisation, globalement, que pour l'AES.
Longueur Minimum
30 WORDs

Tableau PtsIn    : Ce tableau contient des coordonnÇes de points. Chacune
Longueur Minimum   deux WORDs, l'un pour l'abscisse X, l'autre pour l'ordonnÇe
45 WORDs           Y. Les couples se suivent.

Tableau IntOut   : Ce tableau ressemble Ö celui de l'AES, car permet au VDI de
Longueur Minimum   vous rÇpondre en vous envoyant des informations.
30 WORDs

Tableau PtsOut   : Ce tableau sert au VDI pour vous envoyer des couples de
Longueur minimum   coordonnÇes.
12 WORDs

Voila, c'est fini de la description des tableaux du GEM. Je vous l'avait dit
que c'Çtait chiant.
Pour mettre D0.W dans Int_In3, en assembleur 68000, voilÖ ce qu'il faut faire:
                move.l          AES_Params,A0   ; Les adresses des tableaux
                move.l          8(A0),A0        ; dÇbut du tableau Int_In
                move.w          D0,6(A0)        ; D0.W dans Int_In3

La meme chose en assembleur 68030 :
                move.l          AES_Params,A0   ; Les adresses des tableaux
                move.w          D0,([8,A0],6)   ; D0.W dans (A0+8)+6, Int_In3

Vous le voyez par vous meme, c'est assez lourd Ö digerer. C'est ici pour
remplir un seul element, alors pour plusieurs...

Pour selectionner l'AES, ou le VDI, il faut mettre un numero dans D0, et
l'adresse du tableau PARAMS correspondant dans D1.
Ainsi, vos tableaux sont remplis comme il faut, et vous voulez l'AES:
                move.l          #200,D0
                move.l          #AES_Params,D1
                trap            #2

Il n'y a pas Ö restaurer la pile, vu qu'ici on ne l'utilise pas. Dans
l'utilisation via SSAVCALL, il faudra le faire car tout se passera via la pile.
Pour le VDI, cela aurait donnÇ:
                move.l          #115,D0
                move.l          #VDI_Params,D1
                trap            #2

Maintenant, on passe Ö l'offensive, et l'on oublie un peu le cauchemar que l'on
vient de passer. Tout ce que je vais vous expliquer Ö prÇsent utilise la faáon
de proceder de SSAVCALL. Si vous voulez savoir comment faire sans,
achetez un bouquin sur le GEM et un tube d'aspirine Ö 500mg (la paracetamol
marche mieux).

/// Informations... ///////////////////////////////////////////////////////////

Lorsque vous faites appel Ö SSAVCALL, vous obtenez une adresse. Celle ci est le
dÇbut de la routine, oó il faut sauter par un JSR (voyez IVx-SSAV.S). Mais
juste avant cette adresse, il y a 6 BYTEs d'informations...

WORD -3 : NumÇro de la version au format BCD HexaDÇcimal.
            Ex: 0136 est la routine de version 1.36.
WORD -2 : Date d'Assemblage (histoire de se repÇrer dans ses archivages...).
          Màme format que la date systäme (obtenue par T_GETDATE (GEMDOS $2A)).
            BITS  4-0: Le jour (de 0 Ö 31).
            BITS  8-5: Le mois (de 0 Ö 15).
            BITS 15-9: L'annÇe (de 0 Ö 127) plus 1980 (dÇbut du comptage).
                       Donc 2107 au maximum.
            Par exemple, le 11 Mars 1997: BIT  4-0=%01011  (11)
                                          BIT  8-5=%0011   (03)
                                          BIT 15-9=%001001 (17+1980=1997)
WORD -1 : Compteur de tÉches (de 0 Ö 65535)
          Avec ce compteur, vous pouvez savoir combien de tÉches sont en train
          d'exploiter SSAV.
WORD 0-...: The Routine.

/// Appel de SSAVCALL /////////////////////////////////////////////////////////

  Pour utiliser SSAVCALL, il faut connaitre l'adresse de la routine principale.
Pour cela, soit vous cherchez le Cookie (voyez en fin de doc l'explication sur
les Cookies), soit vous le demandez via le TRAP 2.

Vous savez dÇjÖ que pour appeler l'AES, il faut mettre 200 dans D0.
                                   VDI                 115
Pour connaitre l'adresse de SSAVCALL, il faut mettre "SSAV" ($53534156) dans D0.
                move.l          #"SSAV",D0
                trap            #2

Si vous avez toujours "SSAV" dans D0 au retour, c'est que SSAVCALL n'est pas
installÇ, sinon vous avez l'adresse de la routine principale de SSAVCALL
dans D0.

/// L'AES, numÇro 200 /////////////////////////////////////////////////////////

--- LIBRAIRIE APPLICATIONS ---

/// AES  10 : APPL_INIT ///

  Cette fonction sert au GEM pour savoir que vous etes lÖ. Il peut donc vous
envoyer des messages, par exemple pour vous dire qu'une fenetre doit etre
fermÇe. Cela sert aussi pour dialoguer avec d'autres taches, ou les
accessoires.
  Une autre utilisation, c'est de savoir si l'AES est installÇ ou non. Dans la
pratique vous avez fait un programme qui permet de se configurer. Maintenant il
sagit de savoir s'il est executÇ pendant la phase de dÇmarrage de l'ordinateur,
ou depuis le Bureau.
  Pendant la phase de dÇmarrage, l'AES n'est pas installÇ. Donc si vous trouvez
-1, c'est que votre programme est en train d'etre executÇ pendant cette phase.
Profitez en donc pour installez vos routines.
  Depuis le Bureau, l'AES est installÇ, et vous obtenez donc un nombre positif.
Dans ce cas, appelez l'interface de configuration, et utilisez la pour changer
les parametres. N'oubliez pas que vous pouvez les sauver directement dans le
programme (voyez la fin de la doc, sur la BasePage, et le ProgHeader)

Paramätres : LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 10
             WORD : 200
Retour : D0.w = AP_ID (Le Handle du GEM, Ö retenir impÇrativement)
                -1 si erreur, sinon OK (màme 0)
Pile : 8

ATTENTION : ATARI conseille d'ecraser GLOBAL0 pour etre sur que le numÇro de
            l'AES est 0. Apräs APPL_INIT, vÇrifiez GLOBAL0. S'il est toujours Ö
            0, c'est que l'AES n'est pas installÇ, sinon le numÇro dans GLOBAL0
            donne la version de l'AES installÇ.
              N'oubliez pas qu'un AES supÇrieur ou Çgal Ö 4, áa veut dire que
            votre AES est multitache.
              Pour etre sur, vÇrifiez GLOBAL1. S'il est Ö -1, áa veut dire que
            votre AES est multitache

/// AES  11 : APPL_READ ///

  Sert Ö lire un message "Custom", particulier, qui ne tient pas dans les 8
WORDs prÇvus Ö cet effet (Voir la LIBRAIRIE EVENEMENTS). Cette fonction sert
essentiellement pour les dialogues entre les applications, lorsque vous
dÇfinissez vos propres messages. Mais peut aussi recevoir des messages au format
GEM...
  Justement, Ö ce sujet, voyez EVNT_MESAG (AES 23) pour obtenir le format d'un
message typiquement GEM.

Paramätres : WORD : AP_ID de l'application Expeditrice
                    -1 fait une lecture seulement s'il y a un message, sinon
                    revient immÇdiatement Ö votre programme.
             WORD : Longueur du message Ö lire
             LONG : Adresse du tampon du message Ö stocker
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 11
             WORD : 200
Retour : D0.w = 0 si erreur, sinon c'est OK
Pile : 16

/// AES  12 : APPL_WRITE ///

  Sert Ö envoyez un message "Normal" (8 WORDs), ou "Perso" (plus ...), Ö une
application. Il est souhaitable que les 8 premiers mots correspondent au format
standard du GEM, "le reste vous appartient" (Ω Indiana Jones). Pour vos
messages, tachez cependant de garder une certaine logique dans leur
construction.

Paramätres : WORD : AP_ID de l'application Destinataire
             WORD : Longueur du message Ö Çcrire
             LONG : Adresse du tampon du message Ö envoyer
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 12
             WORD : 200
Retour : D0.w = 0 si erreur, sinon c'est OK
Pile : 16

/// AES  13 : APPL_FIND ///

  Tout programme chargÇ est placÇ en mÇmoire avec le nom du fichier associÇ. En
clair, vous chargez TESTSSAV.PRG, et en mÇmoire vous obtenez son code et son nom
(en fait, c'est un peu plus compliquÇ, mais áa marche dans ce style). Grace Ö
cela, le GEM, lors de APPL_INIT, y associe l'AP_ID de TESTSSAV, et simplement
en connaissant le nom du programme, vous pouvez retrouver son AP_ID. Vous
pouvez donc grÉce Ö cela lui envoyer un message, et le GEM se chargera dÇjÖ de
lui le faire parvenir.
  C'est en autre pour cela qu'il est important de passer par Appl_Init (AES 10).

Paramätres : LONG : Pointeur vers le nom de l'application Ö chercher (8
                    caractäres terminÇs par un octet nul. Combler avec des
                    Espaces si le nom fait moins de 8 caractäres)
                    ATTENTION : Si cette adresse ressemble Ö:
                                - $FFFFxxxx oó xxxx est l'ID sous MultiTOS du
                                    programme cherchÇ, APPL_FIND vous donne son
                                    AP_ID sous l'AES
                                - $FFFExxxx oó xxxx est l'AP_ID du pragramme
                                    cherchÇ, APPL_FIND vous donne son ID
                                    correspondant sous MultiTOS
                                - $0, APPL_FIND vous donne votre AP_ID
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 13
             WORD : 200
Retour : D0.w = AP_ID de l'application cherchÇe, sinon -1
Pile : 12

/// AES  14 : APPL_TPLAY ///

Sert Ö rejouer un enregistrement obtenu avec APPL_TRECORD (AES 15).

Paramätres : LONG : Adresse de l'enregistrement.
             WORD : Vitesse de lecture
                    ATTENTION : Ceci est un diviseur.
                                  Lors de l'enregistrement, les ÇvÇnements Timer
                                sont calculÇs en milliäme de seconde. Cependant,
                                lors de la lecture, ces ÇvÇnements Timer sont
                                pris comme dixiäme de seconde. Pour obtenir une
                                vitesse de reproduction identique, il suffit de
                                mettre 100 ici (1000/100=10).
                                  Cela sert pour synchroniser la lecture, pour
                                que la vitesse soit la màme sur des
                                configurations diffÇrentes.
                                  En principe, lorsque vous bougez la souris,
                                entre deux position diffÇrente, vous devriez
                                trouver un ÇvÇnement Timer, qui permet de
                                reproduire la temporisation du "coulÇ" lorsque
                                vous dÇplacez la bàte en question.
                                  En fait, chaque enregistrement est ponctuÇ
                                d'ÇvÇnements Timer.
             WORD : Nombre d'action Ö exÇcuter.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 14
             WORD : 200
Retour : Aucun
Pile : 16

/// AES  15 : APPL_TRECORD ///

  Sert Ö enregistrer des actions utilisateur, comme on peut enregistrer le son
sur FALCON030. Le son est composÇ de deux fois 16 bits pour chaque canal audio
(plus ou moins suivant sont choix). Ici, chaque action est sauvegardÇe sur 6
octets.

Le format est le suivant :
OCTET 0-1 : Type d'ÇvÇnement (0=Timer, 1=Bouton, 2=Souris, 3=Clavier)
OCTET 2-5 : DonnÇe en fonction du type de l'ÇvÇnement (0=Nombre de
            millisecondes ÇcoulÇes, 1=Çtat des boutons, 2=CoordonnÇes X.w et
            Y.w de la souris, 3=Caractäres et Çtat du clavier)

  N'ayez cependant pas peur que votre mÇmoire se remplisse trop vite: s'il ne ce
passe rien pendant un certain temps, vous n'obtiendrez qu'un ÇvÇnement Timer qui
vous indiquera la durÇe entre deux ÇvÇnements. Mais si vous jonglez avec votre
souris, lÖ, attendez vous rapidement Ö un "Plus de mÇmoire...".

Paramätres : LONG : Adresse oó enregistrer. Faites donc attention Ö bien
                    prÇvoir une mÇmoire au moins six fois plus importante que
                    le nombre d'actions Ö enregistrer.
             WORD : Nombre d'actions Ö enregistrer.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 15
             WORD : 200
Retour : D0.w = Nombre d'actions enregistrÇes.
Pile : 14

/// AES  18 : APPL_SEARCH ///

  Sert Ö chercher toutes les applications s'ayant fait connaitre Ö l'AES, et qui
tournent avec vous en mÇmoire.

Paramätres : WORD : Mode
                    0 = Trouver la premiere application
                    1 = Trouver l'application suivante
                    2 = Trouver le Bureau (il est le seul)
                    Cela fonctionne comme F_SFIRST et F_SNEXT du GEMDOS.
             LONG : Adresse du Nom
                    Ce buffer doit faire 9 BYTEs ou plus, pour contenir le nom
                    de l'application. Voyez APPL_FIND.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 18
             WORD : 200
Retour : D0.l = Pointeur vers un tableau de rÇponses du GEM
         Structure du tableau : WORD 0 : RÇsultat
                                         0 = Plus d'application
                                         1 = Pas d'erreur
                                WORD 1 : Type de l'application
                                         1 = Systeme
                                         2 = Application standar
                                         4 = Accessoire
                                WORD 2 : AP_ID de l'application cherchÇe.
Pile : 14

/// AES  19 : APPL_EXIT ///

  Sert Ö indiquer au GEM que l'on voudrait bien Ö prÇsent se passer de ses
inestimables services. En soit, indique au GEM qu'on le quitte, et que ce n'est
plus la peine de nous envoyer les messages d'autres applications, au d'autres
choses.

Paramätres : LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 19
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 8

/// AES 130 : APPL_GETINFO ///

  Sert Ö avoir des informations träs gÇnÇrale sur l'AES installÇ.

Paramätres : WORD : Type
                    0 : Informations sur les fontes normales
                          Retour1 : Hauteur de la fonte
                          Retour2 : ID de la fonte
                          Retour3 : Type de la fonte
                                    0 = Fonte systeme
                                    1 = Fonte externe (GDOS par exemple)
                                    2 = RÇservÇ
                    1 : Informations sur les petites fontes
                          Retour1 : Hauteur de la fonte
                          Retour2 : ID de la fonte
                          Retour3 : Type de la fonte
                                    0 = Fonte systeme
                                    1 = Fonte externe (GDOS par exemple)
                                    2 = RÇservÇ
                    2 : Informations sur la rÇsolution et le nombre de couleurs
                        affichables pour les objets
                          Retour1 : NumÇro de la rÇsolution
                          Retour2 : Nombre de couleurs utilisables pour les
                                    objets
                          Retour3 : Icones couleurs
                                    0 = Pas supportÇs
                                    1 = SupportÇs
                          Retour4 : Nouvelle version des fichiers ressources
                                    0 = Pas supportÇe
                                    1 = SupportÇe
                    3 : Informations sur le langage de l'AES
                          Retour1 : Langage utilisÇ
                                    0 = Anglais
                                    1 = Allemand
                                    2 = Franáais
                                    3 = RÇservÇ
                                    4 = Espagnol
                                    5 = Italien
                                    6 = Suedois
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 130
             WORD : 200
Retour : D0.l = Pointeur vers un tableau de rÇponses du GEM
         Structure du tableau : WORD 0 : RÇsultat
                                         0 = Erreur
                                         1 = Pas d'erreur
                                WORD 1 : Retour1
                                WORD 2 : Retour2
                                WORD 3 : Retour3
                                WORD 4 : Retour4
         Retour1,2,3 et 4 dÇpendent du type d'informations demandÇes
Pile : 10

--- LIBRAIRIE EVENEMENTS ---

/// AES  20 : EVNT_KEYBD ///

  Attend une touche (obtient Ö peu präs le màme rÇsultat que VOID INP(2) en
GFA). Cependant, ne bloque pas le systäme, bien que le dÇroulement du programme
se trouve suspendu (appelez voir un accessoire pour vous rendre compte par vous
màme)

Paramätres : LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 20
             WORD : 200
Retour : D0.w = Code de la touche enfoncÇe (Comme C_RAWCIN (GEMDOS 7))
Pile : 8

/// AES  21 : EVNT_BUTTON ///

  Attend une certaine action de la part de la souris (Çloignez le chat, quelle
trouve le courage de sortir de son trou).

Paramätres : WORD : Nombre de clicks
                    Cela dans un intervalle de temps dÇterminÇ par EVNT_DCLICK
                    (AES 26)
             WORD : Masque de sÇlection
                    BIT 0 = Bouton gauche
                    BIT 1 = Bouton droit
             WORD : Etat attendu
                    BIT 0 = Etat du bouton gauche
                    BIT 1 = Etat du bouton droit
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 21
             WORD : 200
Retour : D0.l = Pointeur vers un tableau de rÇponses du GEM
         Structure du tableau : WORD 0 : Nombre de clicks
                                WORD 1 : CoordonnÇes X lors de l'action
                                WORD 2 : CoordonnÇes Y lors de l'action
                                WORD 3 : Etat des boutons
                                         BIT 0 = Bouton gauche
                                         BIT 1 = Bouton droit
                                WORD 4 : Etat des touches spÇciales
                                         BIT 0 = SHIFT Droit
                                         BIT 1 = SHIFT Gauche
                                         BIT 2 = CONTROL
                                         BIT 3 = ALTERNATE
Pile : 14

/// AES  22 : EVNT_MOUSE ///

  Ici, on attend que la souris se positionne (mais pas toute seule) dans un
certains rectangle dÇfinit par des coordonnÇes.

Paramätres : WORD : Choix de la position
                    0 = Si la souris est dans le rectangle
                    1 = Si la souris est hors du rectangle
             WORD : CoordonnÇe X du coin supÇrieur gauche du rectangle
             WORD : CoordonnÇe Y du coin supÇrieur gauche du rectangle
             WORD : Largeur du rectangle en points
             WORD : Hauteur du rectangle en points
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 22
             WORD : 200
Retour : D0.l = Pointeur vers un tableau de rÇponses du GEM
         Structure du tableau : WORD 0 : CoordonnÇes X lors de l'action
                                WORD 2 : CoordonnÇes Y lors de l'action
                                WORD 3 : Etat des boutons
                                         BIT 0 = Bouton gauche
                                         BIT 1 = Bouton droit
                                WORD 4 : Etat des touches spÇciales
                                         BIT 0 = SHIFT Droit
                                         BIT 1 = SHIFT Gauche
                                         BIT 2 = CONTROL
                                         BIT 3 = ALTERNATE
Pile : 18

/// AES  23 : EVNT_MESAG ///

  Attend un message GEM, voire un message personnel, mais n'excÇdant pas 8
WORDs (taille standard d'un message GEM).

  Voici la structure d'un message GEM, et des autres, comme les vìtres par
exemple : WORD 0 : Type de message
          WORD 1 : AP_ID de l'application Expeditrice du message
          WORD 2 : Si ce WORD n'est pas nul, c'est que le message n'est pas au
                   format GEM Stardard, et comporte des octets supplÇmentaires
                   qu'il vous faudra rÇcupÇrer avec APPL_READ (AES 11). Ce
                   nombre est en principe le nombre d'OCTETs supplÇmentaires Ö
                   lire avec APPL_READ (AES11). Pour cela, vous disposez de tout
                   ce qui est nÇcessaire dans ce message (AP_ID, taille, ...).
          WORD 3 Ö 7 : Suivant le Type de message

Voici Ö prÇsent la liste des diffÇrents messages GEM (attention les yeux, c'est
parti) :

> MN_SELECTED (Type 10)
  Un ÇlÇment du menu a ÇtÇ sÇlectionnÇ.
  WORD 3 : NumÇro du Titre du menu sÇlectionnÇ (vous savez, ce qui se trouve
           dans la barre de menu)
  WORD 4 : NumÇro de l'ÇlÇment sÇlectionnÇ dans ce Titre
  LONG 5 : Adresse de l'arbre contenant le menu PopUp (dans le cas d'une
           gestion de menu PopUp)
  WORD 7 : NumÇro de l'Objet Päre du sous menu (Idem)

  ATTENTION : Gerer les menus n'est pas si simple, vu qu'ils sont arborescent.
              Il y a cependant une astuce, car dans un menu, aucun Titre ou
              EntrÇe n'a le màme numÇro. Ainsi, il suffit de travailler avec les
              numÇro des entrÇes pour se diriger de sous routines en sous
              routines, le numÇro du Titre n'Çtant lÖ que pour nous permettre de
              le faire revenir en Çcriture normale avec Menu_TNormal (AES 33).
              Pour plus de dÇtails, voyez Menu_Bar (AES 30), y'a une Grosse
              Surprize.

> WM_REDRAW (Type 20)
  Une demande de restauration d'une fenàtre (suite Ö la fermeture d'une autre,
  par exemple).
  WORD 3 : Handle de la fenàtre Ö redessiner
  WORD 4 : X du coin supÇrieur gauche
  WORD 5 : Y du coin supÇrieur gauche
  WORD 6 : Largeur de la zone Ö redessiner
  WORD 7 : Hauteur de la zone Ö redessiner

> WM_TOPPED (Type 21)
  Une fenàtre vient d'àtre mise au premier plan (sÇlectionnÇe). C'est Ö vous
  cependant de mettre ladites fenàtre au premier plan, ou ne pas le faire (pour
  d'obscures raisons).
  WORD 3 : Handle de la fenàtre concernÇe

> WM_CLOSED (Type 22)
  Le bouton "Closer" (coin supÇrieur gauche) d'une fenàtre a ÇtÇ cliquÇ, et le
  GEM vous en informe.
  WORD 3 : Handle de la fenàtre sollicitÇe Ö disparaåtre

  ATTENTION : Apräs que vous ayez rÇellement fermÇ cette fenàtre, vous devez
              vous attendre Ö recevoir des messages de Redraw s'il y avait
              d'autres ÇlÇments Ö l'Çcran que la fenàtre avait recouverte. Dans
              ce cas, voyez la section Window (rien Ö voir avec la daube du màme
              nom).

> WM_FULLED (Type 23)
  Le bouton "Fuller" (coin supÇrieur droit) d'une fenàtre a ÇtÇ cliquÇ. Comme il
  est d'usage Ö prÇsent (et tous les livres sur le sujet vous le noterons), au
  premier clic sur cette case, vous devez normalement Çtaler la fenàtre sur tout
  le bureau.
    Au deuxiäme clic cependant, il s'agit de faire revenir Ö son Çtat initial,
  si vous ne l'aviez modifiÇe entre temps. Ainsi, vous devez toujours avoir une
  fenàtre dont les dimension sont celles dÇfinies par l'utilisateur, et une
  fenàtre ouverte sur le bureau.
  WORD 3 : Handle de la fenàtre

> WM_ARROWED (Type 24)
  Une partie des ascenseurs de la fenàtre Ö ÇtÇ activÇe (suivant les ÇlÇments
  dont dispose effectivement la fenàtre, Voir WIND_CREATE (AES 100)).
  WORD 3 : Handle de la fenàtre
  WORD 4 : Element des ascenseurs sÇlectionnÇ et action demandÇe
           0 = WA_UPPAGE : La partie entre la "Cabine" et la fläche vers le haut
                           a ÇtÇ cliquÇe. Cela signifie que l'utilisateur dÇsire
                           remonter rapidement d'une page vers le haut.
                           Cependant, Ö vous de vÇrifier si vous vous trouvez
                           dÇjÖ tout en haut, ou presque (moins d'une page). La
                           notion de page vient en fait des traitement de
                           textes. La taille de la colonne de l'ascenseur doit
                           àtre proportionnelle Ö la longueur du document (Voir
                           VDI), et la "Cabine" reprÇsente le contenu de la
                           fenàtre sur le document.
                             La taille de cette cabine doit àtre elle aussi
                           proportionnelle Ö la taille de la page affichÇe par
                           rapport Ö la taille du document rÇel. Ainsi, si le
                           document ne fait qu'une page, et est affichÇ en
                           entier dans la fenàtre, la "Cabine" doit occuper
                           toute la colonne de l'ascenseur. Si le document
                           occupe deux fois la page affichÇe, la "Cabine"
                           n'occupera que la moitiÇ de la colonne. Cela dÇpend
                           donc aussi de la taille de la fenàtre.
           1 = WA_DNPAGE : Idem que prÇcÇdemment, mais c'est la partie entre la
                           "Cabine" et la fläche vers le bas qui a ÇtÇ cliquÇe.
                           L'utilisateur demande donc d'aller une page vers le
                           bas. Màmes remarques que prÇcÇdemment.
           2 = WA_UPLINE : La fläche vers le haut a ÇtÇ cliquÇ. Si votre
                           programme est un traitement de texte, l'utilisateur
                           demande donc que la fenàtre affiche le document Ö
                           partir d'une ligne prÇcÇdente (en principe). S'il
                           s'agit d'un programme de dessin, cela peut vouloir
                           signifier "Afficher la ligne prÇcÇdent" ou "Afficher
                           les 8 lignes prÇcÇdentes". A vous de voir...
           3 = WA_DNLINE : Pareil, mais fläche vers le bas.
           4 = WA_LFPAGE : Comme WA_UPPAGE ou WA_DNPAGE, mais ici il s'agit de
                           la partie entre la "Cabine Horizontale" et la fläche
                           de gauche.
           5 = WA_RTPAGE : Idem, vers la droite
           6 = WA_LFLINE : Fleche vers la gauche
           7 = WA_RTLINE : Fleche vers la droite

> WM_HSLID (Type 25)
  L'utilisateur Ö directement sÇlectionnÇ la "Cabine Horizontale", la dÇplacÇe,
  et la relÉchÇe Ö un nouvel endroit.
  WORD 3 : Handle de la fenàtre concernÇe
  WORD 4 : Nombre entre 0 (la "Cabine" Ö ÇtÇ dÇplacÇe complätement Ö gauche)
           et 1000 (la "Cabine" butte Ö droite du couloir horizontal)

> WM_VSLID (Type 26)
  Màme chose que prÇcÇdemment, mais pour la "Cabine Verticale".
  WORD 3 : Handle de la fenàtre consternÇe.
  WORD 4 : Nombre entre 0 (oó la "Cabine" est tout en haut) et 1000 (oó elle
           est au "Rez de ChaussÇ")

> WM_SIZED (Type 27)
  L'utilisateur a utilisÇ le bouton "Sizer" (coin infÇrieur droit), Ö changer la
  taille de la fenàtre, et a relÉchÇ le bouton. Le GEM vous communique
  accessoirement la nouvelle taille (mais nÇanmoins la màme coordonnÇe, car
  "Sizer" n'affecte que la taille), que devrait prendre votre fenàtre.
  WORD 3 : Handle de la fenàtre affectÇe
  WORD 4 : X de la fenàtre (en principe, le màme que prÇcÇdemment)
  WORD 5 : Y de la fenàtre (idem...)
  WORD 6 : Nouvelle largeur
  WORD 7 : Nouvelle hauteur

  ATTENTION ICI : Il se trouve que le GEM, bien qu'Çcrit dans un langage pas
                  vraiment speed, vous donne des coordonnÇes "optimisÇes" pour
                  avoir le moins possible Ö rafraåchir l'Çcran. Donc, si la
                  nouvelle taille est infÇrieure, le GEM ne vous donnera Ö
                  retracer que les parties recouvertes, et si les nouvelles
                  dimensions sont supÇrieures, le GEM ne vous demande que
                  d'ajouter ce qu'il y a Ö ajouter.
                    LÖ oó le bas blesse, c'est que s'il se produite un bug Ö
                  l'Çcran, sur une fenàtre, et que vous espÇrez le voir
                  disparaåtre en la modifiant (sur laquelle se trouve, ou en
                  partie, le bug), celui ci restera.
                    Cependant, rien ne vous empàche de retracer Ö chaque fois
                  toute la fenàtre, mais le mieux est bien Çvidement d'avoir un
                  programme rapide, et notoirement bien Çcrit pour Çviter les
                  gros mÇchants Bugs.

> WM_MOVED (Type 28)
  L'utilisateur a utilisÇ la "Barre de Titre", et Ö bougÇ la fenàtre.
  WORD 3 : Handle de la fenàtre "EmmigrÇe"
  WORD 4 : Nouveau X
  WORD 5 : Nouveau Y
  WORD 6 : Largeur (ne devrait pas avoir bougÇ, car la "Barre de Menu" ne
           devrait pas avoir affectÇ la taille)
  WORD 7 : Hauteur (ma foi, ...)

  ATTENTION : Màme remarque que prÇcÇdemment. La fenàtre bougÇe n'est en
              principe pas retracÇe mais copiÇe, et seules les parties occultÇes
              sont retracÇes.

> WM_NEWTOP (Type 29)
  Äa existe, mais je sait pas Ö quoi áa sert. Màmes paramätres que WM_TOPPED. Je
  prÇsume que c'est apräs la premiäre ouverture de la fenàtre, pour que le
  programme sache qu'il a Ö sauvegarder les nouveaux paramätres de cette
  fenàtre, mais ce n'est que pure spÇculation de ma part, et le modeste
  programmeur que je suis (mais quelle grande G...) ne dispose pas d'assez de
  documentations pour vous fournir de plus amples explications.
  WORD 3 : Handle de la fenàtre

> WM_UNTOPPED (Type 30)
  Est envoyÇ lorsque la fenetre en premier plan est envoyÇe en arriere plan par
  la sÇlection d'une autre fenetre.
  Entre nous, c'est juste envoyÇ pour information, pour que vous soyez plus
  prÇcisÇment au courant de ce que l'AES fabrique. Je doute que vous puissiez y
  trouver une utilitÇ quelconque.
  WORD 3 : Handle de la fenàtre

> WM_ONTOP (Type 31)
  LÖ aussi, c'est juste pour info, histoire que vous n'alliez pas crier sur les
  toits que l'on ne vous tienne pas informÇ de ce qui ce passe, et que l'on
  vous cache quelque chose.
  Faites gaffe, si vous cherchez Ö utiliser ce message, car ATARI prÇcise qu'il
  peut se passer plein de choses entre le moment oó la fenetre arrive en
  premier plan, et que vous receviez ce message. Par exemple, que la fenetre en
  question ne soit dÇjÖ plus au premier plan.
  WORD 3 : Handle de la fenàtre

> AC_OPEN (Type 40)
  Sert Ö "Çveiller" un accessoire, soit lorsque l'on le choisit via le "Menu
  Bureau", ou Ö la main, avec APPL_WRITE.
  WORD 3 : NumÇro de l'entrÇe du "Menu Bureau".
           ATTENTION : Rien Ö voir avec le numÇro rÇel du G_STRING qui forme le
                       nom de l'accessoire (voyez MENU_BAR (AES 30)), mais bel
                       et bien le numÇro de l'accessoire.
                         En principe, l'accessoire Ö reáut le màme lors de son
                       installation par MENU_REGISTER. Juste histoire de voir
                       s'il n'y a pas de Bug...

> AC_CLOSE (Type 41)
  Demande Ö l'accessoire de se la boucler (fermer les fenàtres qu'il a
  ouvertes, libÇrer la mÇmoire qu'il squatte, etc...)
  WORD 3 : NumÇro obtenu avec MENU_REGISTER (AES 35).
           Permet de vÇrifier que le GEM s'adresse bien Ö cet accessoire, et
           pas Ö l'autre.

ATTENTION: Ce message peut etre envoyÇ peut fermer un accessoire, sans qu'il y
           ait pour autant changement de rÇsolution..

> AP_TERM (Type 50)
  Lorsque vous recevez ce message, cela veut dire qu'il serait souhaitable de
  terminer au plus vite.
  Fermez vos fenetres, liberez la mÇmoire et la ressource, etc...
  WORD 5 : Les raisons de cet appel

ATTENTION: Les accessoires PEUVENT AUSSI recevoir ce message.

> AP_TFAIL (Type 51)
  Echec dans la procedure d'exctinction.
  WORD 1 : Le code d'erreur

  ATTENTION: envoyez ce message avec SHEL_WRITE mode 10.

> AP_RESCHG (Type 57)
  C'est une sorte de AP_TERM, mais ici, cela veut dire que l'ordinateur ne va
  pas s'arreter, mais changer de rÇsolution.
  Sous un systeme multitache, c'est utile. Imaginez que votre application ne
  supporte pas le TrueColor (programme GFA), et que vous receviez ce message,
  dans ce cas terminez, sinon restez.

> SHUT_COMPLETED (Type 60)
  Ca y est, tout est pres pour etre eteint.
  WORD 3 : 0 = La phase d'exctinction n'a pas aboutie.
               Dans ce cas, cela veut dire qu'une application, ou plusieures,
               ont refusÇes de s'arreter.
               WORD 4 : AP_ID de l'application qui refuse de s'arreter
               WORD 5 : Le code de la raison de son refus.
           1 = Pas de probleme, tout c'est tres bien dÇroulÇ.

> RESCH_COMPLETED (Type 61)
  Ce message est envoyÇ Ö l'application qui demande de changer de rÇsolution.
  WORD 3 : 0 = Erreur
           1 = Pas d'erreur
               Dans ce cas, il faut sortir pour laisser le systeme
               d'exploitation changer de rÇsolution.

> AP_DRAGDROP (Type 63)
  Ce message est envoyÇ lorsque surgit un evenement Drag'n Drop.
  WORD 1 : AP_ID de l'expediteur du message
           Peut etre le Bureau lui meme (0)
  WORD 3 : Handle de la fenetre concernÇe
           -1 si on demande Ö l'application cible de creer et/ou ouvrir une
              nouvelle fenetre.
  WORD 4 : CoordonnÇe X de la souris au relachement
  WORD 5 : CoordonnÇe Y de la souris au relachement
  WORD 6 : Etat des touches spÇciales
  WORD 7 : Nom du "Pipe" (?)

ATTENTION: Il sagit de vÇrifier si les coordonnÇes appartiennent Ö une de vos
           fenetres, et Ö laquelle. Faites attention pour les Drag'n Drop
           d'objet Çditable
           Pour le dialogue, il existe un protocole.

> SH_WDRAW (Type 72)
  Ce message est a envoyer au Bureau pour qu'il rafraichisse les fenetres des
  lecteurs. Votre application copie des fichiers en arriere plan dans la
  partition E, et Ö la fin demande au Bureau de bien vouloir faire apparaitre
  les modification. Si la fenetre concernÇe est ouverte, le Bureau rafraichit,
  sinon il ne se passe rien.
  WORD 3 : NumÇro du lecteur concernÇ (0=A, 1=B, ...)
           -1 pour rafraichir toutes les fenetres

> CH_EXIT (Type 80)
  Ce message est envoyÇ Ö une application pere lorsque son application fille se
  termine. Si l'application pere est le bureau, áa se passe comme un P_TERM. Si
  l'application pere est une application, c'est Ö elle d'agir en consÇquence.
  WORD 3 : AP_ID de l'application fille
  WORD 4 : Code de sortie

ATTENTION: Si vous avez utilisez SHEL_WRITE pour lancer l'application, le
           retour se fera Ö l'AES. Mais bon joueur, il utilisera sa mÇmoire
           pour se souvenir qui lui Ö demandÇ de lancer cette application, et
           fera suivre le message. Donc dans tous les cas, meme si vous n'aviez
           pas programmÇ en tenant compte d'un quelconque systeme multitache,
           vous recevrez ce message.

  REMARQUE : Il existe un moyen de faire des accessoire auto rÇcurrent. Bien que
             l'info ait ÇtÇ diffusÇe dans StraTOS, je l'avais trouvÇ une semaine
             avant (tÇlÇpathie? Non, logique!).
             Pour fermer un accessoire, deux moyens :
              - Appuyer sur le Closer, ou la touche de validation.
              - Quitter l'application en cours (si vous n'àtes pas sous
                MultiTOS), ou changer de rÇsolution.
             Dans le premier cas, c'est votre programme qui gäre la sortie de
             l'accessoire, mais dans le second cas, le GEM vous informe poliment
             qu'il serait bon de disparaåtre, ou que cela va avoir lieu, et
             qu'il devient donc inutile de gÇrer l'accessoire puisque celui ci
             ne sera de toute maniäre plus prÇsent Ö l'Çcran.
               StraTOS conseille, dans ce cas, de rÇ-ouvrir l'accessoire au bout
             de huit secondes environ (rechargement des diffÇrents accessoires,
             du bureau, installation du bordel, et surtout si vous avez DeskPic
             en route avec un chargement d'une image GIF en 256 couleurs).
               De mon cotÇ, je ne peut hÇlas vous conseiller mieux, car Ö ma
             connaissance, il n'existe aucun moyen de savoir quand exactement le
             bureau Ö vÇritablement fini de s'installer, et donc quand votre
             accessoire serait le plus propice Ö se rouvrir.
               Une indication pour celui qui tiens Ö chercher : juste Ö la fin
             de l'installation du bureau, le disque dur fait un cours accäs...
             De lÖ, les possibilitÇs sont infinies.
               NÇanmoins, une fois que les accessoires sont chargÇs, la boucle
             principale est executÇe, donc en principe c'est Ö ce moment lÖ
             qu'il sagit de vÇrifier si l'accessoire Çtait dÇjÖ prÇsent avant
             de fermer l'application ou de changer de rÇsolution (n'oubliez pas
             que l'on peut dÇselectionner le votre avec diffÇrents outils, ou
             en gardant pressÇe la touche Control), et s'il Çtait ouvert. Le
             TOS Çtant pseudo-multitache (uniquement pour les accessoires),
             d'ouvrir le votre alors qu'un accessoire est en train de
             travailler ne devrait pas poser de probleme (juste un petit
             retard, le temps que le GEM s'occupe de vous).

Paramätres : LONG : Adresse du tampon du message (un ds.w 8 quelque part dans
                    votre programme fait träs bien l'affaire)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 23
             WORD : 200
Retour : Aucun
Pile : 12

REMARQUE : Il arrive dans certains programme (presque tous en fait), que le
           programme utilise le message au plus deux fois.
             En clair, apräs avoir exÇcutÇ une action dont l'ordre provenait
           d'un message, celui ci se trouvant encore intÇgralement en mÇmoire,
           le programme va l'exÇcuter une deuxiäme fois.
             Dans la pratique, l'exemple le plus stressant, c'est lorsque vous
           cliquez dans un ascenseur d'une fenàtre pour descendre d'une page de
           texte par exemple, et que le programme descende de deux pages, sans
           que vous puissiez faire quoi que ce soit.
             En fait, pour stopper le processus, pendant que le programme
           effectue l'affichage de la page suivante, cliquez sur le bureau, le
           message change, et le programme est leurrÇ.

             Donc, dans le cas gÇnÇral, le mieux est d'effacer le WORD du type
           du message apräs l'avoir exÇcutÇ, histoire d'Çviter ce probläme.

/// AES  24 : EVNT_TIMER ///

Pause en millisecondes Ö effectuer. L'utilitÇ de cette fonction est discutable.
La pause maximum est de 49 jours, 17 heures, 2 minutes, 47 secondes et 295
milliämes.

Paramätres : LONG : Nombre de millisecondes Ö attendre.
                    Normalement les deux WORDs qui composent ce LONG doivent
                    àtres inversÇs, mais ne vous inquiÇtez pas, SSAV s'occupe de
                    tout (Le WORD de poids faible Ö la place du WORD de poids
                    fort, et inversement : devinez pas la faute Ö qui, Big Blue
                    ou Bill Gates?)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 24
             WORD : 200
Retour : Aucun
Pile : 12

/// AES  25 : EVNT_MULTI ///

Combinaison de pratiquement tous les appels de gestions vu jusqu'ici. La cerise
sur le gÉteau (ou l'ananas si vous prÇfÇrez), c'est qu'il est possible de gÇrer
deux EVNT_MOUSE diffÇrents (donc Ö gÇrer deux zones diffÇrentes).
  De plus, vu que vous gÇrez plusieurs ÇvÇnements en màme temps, vous n'àtes
plus obligez de rÇpartir le travail en plusieurs fois.
Cette fonction est le noyau de XForm_Do et de SSX2Form_Do.

Paramätres : WORD : Type d'ÇvÇnement
                    BIT 0 = Clavier (Voir EVNT_KEYBD (AES 20))
                    BIT 1 = Boutton (Voir EVNT_BUTTON (AES 21))
                    BIT 2 = (Voir EVNT_MOUSE (AES 22))
                    BIT 3 = (Voir EVNT_MOUSE (AES 22))
                    BIT 4 = Message (Voir EVNT_MESAG (AES 23))
                    BIT 5 = Timer (Voir EVNT_TIMER (AES 24))
               EVNT_BUTTON
             WORD : Nombre de clicks
             WORD : Masque de sÇlection
             WORD : Etat attendu
               EVNT_MOUSE(1)
             WORD : Choix de la premiäre position
                    0 = Si la souris est dans le rectangle
                    1 = Si la souris est hors du rectangle
             WORD : CoordonnÇe X1 du coin supÇrieur gauche du rectangle
             WORD : CoordonnÇe Y1 du coin supÇrieur gauche du rectangle
             WORD : Largeur1 du rectangle en points
             WORD : Hauteur1 du rectangle en points
               EVNT_MOUSE(2)
             WORD : Choix de la deuxiäme position
                    0 = Si la souris est dans le rectangle
                    1 = Si la souris est hors du rectangle
             WORD : CoordonnÇe X2 du coin supÇrieur gauche du rectangle
             WORD : CoordonnÇe Y2 du coin supÇrieur gauche du rectangle
             WORD : Largeur2 du rectangle en points
             WORD : Hauteur2 du rectangle en points
               EVNT_TIMER
             LONG : Nombre de millisecondes Ö attendre
               EVNT_MESAG
             LONG : Adresse du tampon du message (un ds.w 8, ou plus)
             LONG : Addresse du buffer des variables (AES_PARAMS)
             WORD : 25
             WORD : 200
Retour : D0.l = Pointeur vers un tableau de rÇponses du GEM
         Structure du tableau : WORD 0 : Type d'ÇvÇnement survenue (parmi ceux
                                         dÇfinis dans le premier paramätre de
                                         EVNT_MULTI)
                                WORD 1 : CoordonnÇe X de la souris Ö
                                         l'apparition de l'ÇvÇnement
                                WORD 2 : CoordonnÇe Y de la souris
                                WORD 3 : Etat des boutons
                                WORD 4 : Etat des touches spÇciales
                                WORD 5 : Code Clavier - Code ASCII
                                WORD 6 : Nombre de clics

Pile : 44

/// AES  26 : EVNT_DCLICK ///

Sert Ö obtenir ou Ö fixer la vitesse de double click de la souris.

Paramätres : WORD : Vitesse de double click (0 = Lent Ö 4 = Rapide)
             WORD : Mode (0 = Lecture de la vitesse, 1 = Ecriture)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 26
             WORD : 200
Retour : D0.w = Vitesse lue (Si Mode = 0), sinon vitesse Çcrite
Pile : 12

--- LIBRAIRIE MENUS ---

/// AES  30 : MENU_BAR ///

Sert Ö afficher ou Ö effacer la barre de menu du GEM. A l'affichage du nouveau
menu, le GEM se charge de remplacer les places rÇservÇes dans le menu principal
par les accessoires en mÇmoire.

  Je tiens Ö avertir les dÇbutants, car la gestion des menus est assez ardue de
prime abord. Cependant, j'utilise une "astuce", qui n'est en fait qu'un baguage
Ö mon style de programmation. Les bidouilleurs qui se seront dÇjÖ empressÇ de
dÇsassembler SSAV auront dÇjÖ compris mon ... truc. En fait, c'est comme
l'assembleur, c'est logique. Mais je vous invite Ö suivre deux minutes fortement
didactiques.
  Il se trouve que dans le cas gÇnÇral, le premier Titre d'un menu porte le
numÇro 3. Le suivant le 4, et ainsi de suite. Ainsi, si votre menu comporte 4
Titres, le dernier se verra attribuer le numÇro 6 (1¯=3, 2¯=4, 3¯=5 et 4¯=6).
Mais dans ce màme cas gÇnÇral, il se trouve que la premiäre EntrÇe soit notre
inconditionnelle "A Propos De..." dans le premier Titre. Cette entrÇe sert dans
le cas ... gÇnÇral vous l'aurez devinÇ, Ö donner des informations sur l'auteur,
le programme, ou... suivant le grÇ de notre amis ressourciste (NdC : áa
existe?).
  Cette premiäre EntrÇe, en la matiäre, se voit dÇfinir le numÇro du dernier
Titre, plus 3. Dans notre exemple donc 9. Cela car l'Objet, et oui, apräs le
dernier Titre est un I-Box. Le suivant Çtant la boite contenant les EntrÇes du
premier Titre.
  Donc, apräs notre premiäre EntrÇe, la 9, se trouve une ligne pour dÇlimiter
votre menu et les accessoires. Celle ci porte le numÇro 10, et les EntrÇes pour
les accessoires 1 Ö 6 respectivement 11 Ö 16. L'Objet 17 est la boite contenant
les EntrÇe du deuxiäme Titre. Ainsi de suite, jusqu'a la fin. ComplÇtons
l'exemple par une dÇfinition exacte de notre menu.
TestSSAV (Titre 3)
 I-Box (numÇro 7)
 Box TestSSAV (numÇro 8)
  A Propos De... (EntrÇe 9)
  -------------- (numÇro 10)
  Acc 1          (EntrÇe 11)
  Acc 2          (EntrÇe 12)
  Acc 3          (EntrÇe 13)
  Acc 4          (EntrÇe 14)
  Acc 5          (EntrÇe 15)
  Acc 6          (EntrÇe 16)
Fichiers (Titre 4)
 Box Fichiers (numÇro 17)
  Nouveau     (EntrÇe 18)
  Ouvrir      (EntrÇe 19)
  ----------- (numÇro 20)
  Sauver      (EntrÇe 21)
  Sauver sous (EntrÇe 22)
  ----------- (numÇro 23)
  Quitter     (EntrÇe 24)
Affichage (Titre 5)
 Box Affichage (numÇro 25)
  Fenàtres    (EntrÇe 26)
  Formulaires (EntrÇe 27)
Graphisme (Titre 6)
 Box Graphisme (numÇro 28)
  Ligne     (EntrÇe 29)
  Rectangle (EntrÇe 30)

Je suppose que vous avez compris, donc continuons.
  Dans ce menu vous n'avez pas besoin de gÇrer les lignes, les Titres (car ce
n'est pas avec un Titre que vous allez ouvrir un formulaire), les diffÇrentes
boites, et bien sur les accessoires. Mais si vous n'avez pas Ö les gÇrer, rien
ne doit vous empàcher de prÇvoir assez grand pour ne pas avoir Ö vous prendre le
melon sur un casse tàte. Voyons Ö prÇsent ma formule magique.
  Il existe cependant bien d'autre maniäre de gÇrer un menu, mais je pense que
dans un but de dÇveloppement en assembleur, cette version offre beaucoup
d'avantages.
  Imaginez vous que l'on vient de sortir d'une demande d'ÇvÇnement avec
Evnt_Mesage par exemple, et que l'on attend quelque chose pour le menu. Le Type
est Ö 10, donc c'est pour nous, et il s'agit de jouer serrÇ.

                ...

                pea             Menu_Return     ; On se prÇpare au retour

                lea             Messag_Tab,A0
                move.w          (8,A0),D0       ; Le numÇro de l'EntrÇe
                cmpi.w          #31,D0          ; On vÇrifie que l'on est bien
                                                ; dans une certaine limite,
                                                ; histoire d'Çviter le gros
                                                ; mÇchant bug
                BGE             Menu_Exit       ; Oups...
                lea             Menu_Jump,A1
                JMP             (A1,D0.w*4)     ; Warp (un BRA prend 4 octets)
                RTS                             ; On met un filet, au cas ou

Menu_Jump       BRA             Menu_Exit       ; c'est quoi l'Objet 0?
                BRA             Menu_Exit       ; Et le 1?
                BRA             Menu_Exit       ; Et le 2?
                BRA             Menu_Exit       ; C'est un Titre, et il ne
                BRA             Menu_Exit       ; peut donc àtre sÇlectionnÇ
                BRA             Menu_Exit       ; en tant qu'EntrÇe. Donc, on
                BRA             Menu_Exit       ; s'en fout
                BRA             Menu_Exit       ; La fameuse I-Box
                BRA             Menu_Exit       ; La Box TestSSAV
                BRA             Infos           ; A Propos De...
                BRA             Menu_Exit       ; La ligne
                BRA             Menu_Exit       ; Acc 1
                BRA             Menu_Exit       ; Acc 2
                BRA             Menu_Exit       ; Acc 3
                BRA             Menu_Exit       ; Acc 4
                BRA             Menu_Exit       ; Acc 5
                BRA             Menu_Exit       ; Acc 6
                BRA             Menu_Exit       ; La Box Fichier
                BRA             New             ; Nouveau
                BRA             Load            ; Charger
                BRA             Menu_Exit       ; La ligne
                BRA             Save            ; Sauver
                BRA             Save_As         ; Sauver sous
                BRA             Menu_Exit       ; La ligne
                BRA             Quit            ; Quitter
                BRA             Menu_Exit       ; La Box Affichage
                BRA             Windows         ; Fenetres
                BRA             Forms           ; Formulaires
                BRA             Menu_Exit       ; La Box Graphisme
                BRA             Line            ; Ligne
                BRA             Rect            ; Rectangle

Menu_Return     move.w          (6,A0),D0       ; On suppose que l'on a pas
                                                ; touchÇ Ö A0, que l'on pointe
                                                ; encore le buffer des
                                                ; ÇvÇnements, et qu'il nous
                                                ; suffit de rÇcupÇrer le
                                                ; numÇro du Titre Ö faire
                                                ; revenir en Çcriture normale
                BSR             MENU_TNORMAL

Menu_Exit       RTS                             ; On sort de la gestion

Infos           ; Il s'agit d'afficher votre formulaire, et de le gÇrer

                RTS                             ; A cause du pea, qui Ö simulÇ
                                                ; un BSR en empilant l'adresse
                                                ; de Menu_Return, on y va.

MENU_TNORMAL    move.l          Menu_Adr,-(SP)  ; Adresse du menu
                move.w          D0,-(SP)        ; NumÇro du Titre
                move.w          #1,-(SP)        ; Normal
                pea             AES_Params
                move.w          #33,-(SP)       ; - MENU_TNORMAL -
                move.w          #200,-(SP)      ; *** AES ***
                JSR             ([SSAV_Adr])
                lea             (16,SP),SP

                RTS

Menu_Adr        ds.l            1               ; Adresse du Menu actuel
Message_Tab     ds.w            8               ; Le buffer pour les ÇvÇnements

  Ainsi, vous disposez d'un exemple de gestion simpliste d'un menu. Si celui ci
occupe beaucoup de place, que ce n'est pas fin de ma part de procÇder ainsi, que
je risque de m'attirer les foudres des Dieux puristes du GEM, il est nÇanmoins
relativement comprÇhensible, et facilement modifiable (il suffit de rajouter des
lignes en cas de rajout d'EntrÇes). Sachez tout de màme que vu que les Boxs et
autres lignes ne peuvent àtres sÇlectionnÇes, jamais ces sauts ne serviront,
mais je les mets pour une raison de lisibilitÇ, et au cas ou un bug vicieux
viendrait vous polluer la vie (bweark...).
  Pour ceux qui veulent gÇrer deux menu (voyez donc TestSSAV), il se trouve un
probläme lors du retour au menu prÇcÇdent. Vu que le message ÇvÇnement
enregistrÇ est celui du menu que l'on quitte (le deuxiäme), Menu_Return ne
trouvera pas dans le message le bon numÇro du Titre (du premier menu) Ö changer
(celui qui vous a envoyÇ dans le second menu). Pourtant ce Titre (du premier
menu) est en inverse vidÇo en mÇmoire.
  Si vous affichez tel quel le menu, vous aurez la surprise de voir apparaåtre
le Titre en inverse (car disons pour TestSSAV, j'utilise la premiäre EntrÇe du
premier Titre du deuxiäme menu pour revenir au premier menu, donc le numÇro de
Titre du message sera Ö 3 (n'oubliez pas que 3 est le numÇro du premier
Titre)[inspiration profonde...], donc au retour, se sera le premier Titre du
premier menu qui reviendra en normal, alors qu'il y est dÇjÖ)[Expiration
soulagÇe...].
  La solution consiste avant de revenir, de placer Ö la main le numÇro du Titre
qui a invoquÇ le nouveau menu. En principe, vous savez dans quel Titre se trouve
l'EntrÇe en question, et ne devrais pas changer. De placer le numÇro du Titre ne
fait pas planter l'ordinateur, mais placez bien ce numÇro oó il faut...

Paramätres : LONG : Adresse du menu (A obtenir avec RSRC_GADDR (AES 100) si l'on
                    travail avec des ressources).
                      Certains finissent avec 0 ici. Allez savoir pourquoi, car
                    l'application suivante force automatiquement l'apparition de
                    la barre de menu par l'appel de cette fonction, que cela
                    soit le Bureau ou autre chose.
             WORD : Mode
                    0 = DÇsactive le menu
                    1= Active la chose
                    -1= Demande l'AP_ID de l'application Ö laquelle appartient
                        la barre de menu affichÇe. Le retour se fait dans D0
                        dans ce cas.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 30
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK. Peut etre un AP_ID.
Pile : 14

ATTENTION : Il se peut que vous veniez Ö rajouter des EntrÇes dans un menu, mais
            que vous oubliez d'en faire de màme avec le programme de gestion. Si
            cela vous arrivais, vous vous en rendriez compte immÇdiatement, car
            une boite ne correspondant pas Ö l'EntrÇe dÇsirÇe s'ouvrira, par
            exemple.
              De plus, il se peut qu'en ajoutant des EntrÇe Ö la fin de votre
            menu (dernier Titre), et que vous oubliez de modifier le nombre
            maximum d'EntrÇe, juste avant le saut qui lui màme vous enverra dans
            la routine de gestion adÇquate, le chiffre de l'EntrÇe sera trop
            grand, et vous serez renvoyez Ö Menu_Exit sans autre forme de procäs
            (voyez le cmpi avant Menu_Jump).
              Cependant, vu que le message est correct, le Titre reviendra en
            Çcriture normal, mais vous n'obtiendrez pas ce que vous attendiez.

Je tiens Ö vous donner quelques informations plus complätes.
L'Objet 0 du menu est une IBox, qui se trouve àtre le bureau en lui màme. C'est
grÉce Ö cela que DeskPic et compagnie mettent une image dans le fond, en foráant
le GEM Ö changer d'Objet 0.
L'Objet 1 est une Box avec un bord. C'est simplement la barre de menu.
L'Objet 2 est une IBox qui contient les Titres.
Notre IBox 7 contient toutes les Box rÇunissant les EntrÇes.
Voici donc l'Arborescence de notre menu :
G_IBox 0 : Bureau
 G_Box 1 : Barre de menu
  G_IBox 2 : Boite avec les Titres
   G_Title 3 : TestSSAV
   G_Title 4 : Fichier
   G_Title 5 : Affichage
   G_Title 6 : Graphisme
 G_IBox 7 : Espace de travail
  G_Box 8 : Boite du titre TestSSAV
   G_STRING 9 : A Propos De..
... Le reste est du màme acabit, Ö raison d'un G_String par EntrÇe.

Un appel Ö l'Çquipe de Double Click SoftWare : Mais comment faites vous donc
avec DCPOPUP pour transformer n'importe quel menu en Pop-Up hiÇrarchique?

/// AES  31 : MENU_ICHECK ///

Sert Ö afficher un petit  (CHR$(8)) devant une ligne d'un menu. Par exemple
pour fixer un paramätre (utilisation du ClipBoard dans 7UP).

Paramätres : LONG : Adresse du menu (Màme remarque que prÇcÇdemment)
             WORD : NumÇro de l'ÇlÇment Ö marquer (Titre ou EntrÇe)
             WORD : Mode (0 = Efface la marque ou 1 = Affiche la marque)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 31
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 16

/// AES  32 : MENU_IENABLE ///

Sert Ö rendre une ligne d'un menu inactive. On ne peut plus ensuite sÇlectionner
cette ligne. Elle devient grise (comme les lignes de sÇparations dans les
menus).

Paramätres : LONG : Adresse du menu (Màme remarque que prÇcÇdemment)
             WORD : NumÇro de l'ÇlÇment Ö afficher en clair
             WORD : Mode (0 = Ecrit en clair ou 1 = Ecrit en normal)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 32
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 16

/// AES  33 : MENU_TNORMAL ///

Sert Ö afficher une ligne d'un menu en inversÇ.
  Si dans votre menu, vous avez sÇlectionnÇ une ligne, il FAUT utiliser cette
commande pour lui faire retrouver son aspect original, car le GEM ne s'en occupe
pas.
  Si vous ne le faite pas, la prochaine fois que vous dÇroulerez le menu qui
contient la ligne, celle ci sera en inverse vidÇo. C'est justement ce qu'il
arrive aux Titres, dont il faut changer l'Ob_State non pas avec OBJC_CHANGE,
mais avec cette fonction.

Paramätres : LONG : Adresse du menu (Màme remarque que prÇcÇdemment)
             WORD : NumÇro de l'ÇlÇment Ö afficher en inverse vidÇo
             WORD : Mode (0 = Ecrit en inverse ou 1 = Ecrit en normal)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 33
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 16

/// AES  34 : MENU_TEXT ///

Sert Ö changer le texte d'un ligne d'un menu, par exemple pour indiquer le fait
qu'une fonction est active ou pas (voir MENU_ICHECK (AES 31)). Le nouveau texte
ne DOIT pas àtre plus long que le texte Ö remplacer, sinon ... BOUM.

Paramätres : LONG : Adresse du menu (Màme remarque que prÇcÇdemment)
             WORD : NumÇro de l'ÇlÇment Ö changer
             LONG : Adresse du nouveau texte (Se terminant par 0, et pas plus
                    long que l'ÇlÇment actuellement affichÇ, sinon...)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 34
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 18

/// AES  35 : MENU_REGISTER ///

Sert Ö installer le titre d'un accessoire dans le menu Bureau.
  Attention, contrairement Ö Menu_Bar, il ne s'agit pas ici de faire apparaåtre
le nom des accessoires prÇsents en mÇmoire aux emplacements qui leurs sont
rÇservÇs, mais belle et bien d'indiquer au GEM que vous voulez installer un
nouvel accessoire, dans la mesure du possible.
  Si vous obtenez rÇparation, donc que le GEM vous gratifie de la chance de
pouvoir figurer Ö tout moments dans la barre de menu, il vous faudra entrer dans
une boucle sans fin, et attendre le message d'ouverture AC_OPEN (Type 40). A ce
moment lÖ, allez dans une boucle pour gÇrer vos formulaire et fenàtres.
  Cependant, ne rÇservez pas de mÇmoire, ou alors Ö titre vraiment temporaire
car dans ce cas, le GEM n'inscrira pas l'appartenance du bloc mÇmoire Ö vous,
mais Ö la tache actuellement en utilisation (le programme en cours, quoi). S'il
vient Ö disparaåtre, les blocs mÇmoires rÇservÇs lors de son existence sont
rendus, et vous, vous plantez le systäme, HÇ, con... C'est d'ailleurs pour cela
que RSRC_LOAD ne procäde pas de cette maniäre, et dans ce cas, la ressource
chargÇe vous appartient vÇritablement.

Paramätres : WORD : AP_ID de l'accessoire
                    -1 = RÇÇcrit le nom de l'accessoire, qui peut avoir changÇ.
             LONG : Adresse du titre de l'accessoire (Se terminant par 0)
                    N'excedez pas 16 caracteres pour le nom de votre
                    accessoire.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 35
             WORD : 200
Retour : D0.w = NumÇro de l'accessoire (0 Ö 5), -1 si il n'y a plus de place
Pile : 14

ATTENTION : Il existe un "grugeur" qui Çtend le nombre d'accessoire Ö 36. Votre
            accessoire doit donc faire attention Ö ne pas se limiter de 0 Ö 5.

/// AES  36 : MENU_POPUP ///

Sert Ö afficher et Ö gÇrer un menu du type Pop-Up.
  Ne fonctionne qu'a partir de l'AES 3.4, inclus dans les TOS 4. Ces menus ont
une structure arborescente, assez difficile Ö mettre en oeuvre Ö la main, mais
grÉce au nouvel AES, "no problemo" (Ω Terminator). Deux nouvelles structures
viennent Çtoffer un nombre dÇjÖ considÇrable de ces tableaux de maåtres.

> Structure Menu_Pop
  Cette structure dÇfinie un menu du type PopUp.
  LONG : Adresse de l'arbre contenant le menu
  WORD : NumÇro de l'Objet Päre du menu. Comme vous l'avez vu, les EntrÇes d'un
         menu sont contenus dans une Box. Ici, les EntrÇe du menu PopUp DOIVENT
         àtres contenus dans une G-Box dont le cadre est de un pixel vers
         l'extÇrieur, et dont le BIT Shadowed est mis. Chaque EntrÇe de ce menu
         doit àtre un G_String.
         En principe, dans un màme arbre, on peut mettre plusieurs menu PopUp,
         mais c'est foireux, alors mettez en un par arbre.
  WORD : Objet de dÇpart du menu. Si c'est un menu de type hiÇrarchique, ce sera
         l'EntrÇe placÇe tout en haut, et dans le cas d'un menu PopUp, c'est
         l'EntrÇe qui devra se trouver en face du bouton d'appel.
  WORD : Si c'est Ö 0, le menu est fixe, sinon les EntrÇes situÇes entre
         l'EntrÇe dont le numÇro d'ordre est contenu dans ce WORD, et la fin,
         peuvent scrooler car le GEM ajoute des fläches pour pouvoir faire
         cela sans problämes.

> Structure Menu_Set
  Cette structure dÇfinie le comportement d'un menu PopUp.
  LONG : DÇlai en milliäme de seconde entre le moment oó la souris arrive (ou
         passe) sur une EntrÇe liÇe Ö un sous menu, et le moment oó celui ci
         doit s'afficher. C'est pratique car si vous passez rapidement sur les
         EntrÇe, le sous menu ne s'affiche pas immÇdiatement, et ne ralentit pas
         la gestion de la souris. 200 en une valeur normale.
  LONG : DÇlai en milliäme de seconde entre le moment oó le sous menu Ö ÇtÇ
         ouvert, et le moment oó il doit se fermer si la souris n'est pas passÇe
         sur le sous menu. En principe c'est 10000 qu'il faut mettre ici, mais
         áa marche pas de toute maniäre (bravo Digital Research).
  LONG : DÇlai toujours en milliäme de seconde entre le moment oó l'on clique
         sur une fläche de scrool, et oó celui ci scroole vraiment. 250 est un
         bon choix, bien que je prÇfäre 150, qui est plus dynamique.
  LONG : DÇlai, comme d'habitude, entre chaque changement de ligne. Mettez ici
         100 pour Çviter un dÇfilement trop rapide.
  WORD : Nombre d'options visualisables dans ce sous menu.

Paramätres : LONG : Adresse d'une Structure Menu_Pop
             WORD : X de la G_Box du menu PopUp Ö afficher
             WORD : Y Ö afficher
             LONG : Adresse de la boite Ö afficher
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 36
             WORD : 200
Retour : D0.w = 0 si rien n'a ÇtÇ cliquÇ, 1 si il y a eut quelque chose
Pile : 20

ATTENTION : Un menu Pop-Up peut etre affichÇ n'importe oó Ö l'Çcran. De plus,
            c'est Ö vous de vous occuper de son Clipping.
            Le retour du numÇro du menu se fera par un message.

/// AES  37 : MENU_ATTACH ///

Sert Ö lier un Objet Ö une EntrÇe d'un menu comme menu hiÇrarchique, ou Pop-Up.
Celui-ci sera traitÇ avec MENU_PopUp. Vous pouvez crÇer 4 niveau de menus PopUps
(un PopUp d'un PopUp d'un PopUp d'un PopUp d'une EntrÇe).
Ne JAMAIS lier la premiäre EntrÇe (A Propos De...) Ö un menu PopUp.

Paramätres : WORD : Mode
                    0 = Informations sur le lien actuel (ne fonctionne pas)
                    1 = CrÇe ou modifie un lien
                    2 = DÇtruit un lien
             LONG : Adresse du de l'arbre contenant le menu
             WORD : NumÇro de l'EntrÇe
             LONG : Adresse d'une Structure Menu_Pop dÇcrivant le sous menu
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 37
             WORD : 200
Retour : D0.w = 0 si Çchec, 1 si OK.
Pile : 22

/// AES  38 : MENU_ISTART ///

Permet de dÇfinir dans un menu hiÇrarchique quelle EntrÇe sera la premiäre du
scrool.

Paramätres : WORD : Mode
                    0 = Informations sur le numÇro de l'EntrÇe du sous menu
                    1 = Fixer ou modifier ce numÇro
             LONG : Adresse de l'arbre contenant le sous menu
             WORD : NumÇro de l'Objet Päre du sous menu
             WORD : NumÇro de l'EntrÇe du sous menu Ö fixer au dÇpart
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 38
             WORD : 200
Retour : D0.w = 0 si echec, sinon OK.
Pile : 18

/// AES  39 : MENU_SETTING ///

Permet de changer les paramätres du comportement d'un sous menu.

Paramätres : WORD : Mode
                    0 = Informations sur les choix actuels
                    1 = Fixer ou changer ces choix
             LONG : Adresse d'une Structure Menu_Set
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 39
             WORD : 200
Retour : D0.w = Toujours 1
Pile : 16

--- LIBRAIRIE OBJETS ---

La Librairie Objet permet de travailler avec des Ressources. Celles ci
contiennent des Objets (un bouton, une boite, un texte, une icìne, etc...).
Voici les diffÇrentes structures des Objets, ainsi qu'une explication :

> Structure d'un Objet
  Chaque Objet en mÇmoire occupe un tableau contenant toutes les informations
  pouvant le dÇcrire. Chaque tableau "Struct Object" occupe 12 WORDs.
  WORD 0 : Ob_Next : NumÇro du prochain Objet, au màme niveau. Ainsi, un Fils
                     pointe son Fräre. Si c'est le dernier, il pointe le Päre.
  WORD 1 : Ob_Head : NumÇro du premier Objet Fils
  WORD 2 : Ob_Tail : NumÇro du dernier Objet Fils
  WORD 3 : Ob_Type : Type de l'Objet. En voici la liste :
                     - G_BOX (Type 20) : Boite simple, avec cadre et couleur
                                         intÇrieur
                         Ob_Spec : Voir Structure Ob_Spec
                     - G_TEXT (Type 21) : Texte simple
                         Ob_Spec : Voir Structure TedInfo
                     - G_BOXTEXT (Type 22) : Texte simple avec boite simple
                         Ob_Spec : Voir Structure TedInfo
                     - G_IMAGE (Type 23) : Image, sans masque
                         Ob_Spec : Voir Structure BitBlk
                     - G_USERDEF (Type 24) : Objet Custom, Ö vous d'Çcrire la
                                             routine graphique qui va dessiner
                                             cet Objet (bouton Ö la "Mac",
                                             texte en relief, ...). L'AES saute
                                             Ö la routine que vous lui
                                             prÇcisez, et trace l'Objet
                                             (profitez en).
                         Ob_Spec : Voir UserBlk
                     - G_IBOX (Type 25) : Boite vide, avec cadre cependant
                         Ob_Spec : Voir Structure Ob_Spec
                     - G_BUTTON (Type 26) : Boite simple avec texte centrÇ
                         Ob_Spec : Pointe le texte Ö afficher
                     - G_BOXCHAR (Type 27) : Une lettre dans une boite simple
                         Ob_Spec : Voir Structure Ob_Spec
                                   BIT 24 Ö 31 : le code ASCII du caractäre Ö
                                                 afficher
                     - G_STRING (Type 28) : Texte simple
                         Ob_Spec : Pointe le texte Ö afficher
                     - G_FTEXT (Type 29) : Texte formatÇ
                         Ob_Spec : Voir Structure TedInfo
                     - G_FBOXTEXT (Type 30) : Texte formatÇ dans une boite
                                              simple
                         Ob_Spec : Voir Structure TedInfo
                     - G_ICON (Type 31) : Icone avec masque
                         Ob_Spec : Voir IconBlk
                     - G_TITLE (Type 32) : Titre de menu
                         Ob_Spec : Pointe le Titre du menu
                     - G_CICON (Type 33) : Icone couleur, avec icìne
                                           sÇlectionnÇ et version monochrome
                         Ob_Spec : Voir Stucture CIconBlk
  WORD 4 : Ob_Flags : Masque d'Action. DÇfinit les caractÇristiques d'Actions
                      d'un Objet. Voici la signification de BITs :
                      BIT 0 : SELECTABLE : L'Objet peut àtre sÇlectionnÇ
                      BIT 1 : DEFAULT : SÇlectionne cet Objet si l'on appuie
                                        sur RETURN
                      BIT 2 : EXIT : Termine la gestion du formulaire.
                                     NÇcessite de relÉcher le bouton.
                      BIT 3 : EDITABLE : On peut Çditer un Champ Editable
                                         (entrer une phrase, ou un code, le tout
                                         au clavier). ATTENTION Ö ne pas
                                         affecter un bouton ou quoi que ce soit
                                         qui ne soit pas rÇellement Çditable
                                         avec ce BIT, sinon...
                      BIT 4 : RBUTTON : Radio Button, nÇcessite d'appartenir Ö
                                        un Päre commun, et d'avoir au moins un
                                        Fräre. Un seul Radio Button ne peut àtre
                                        sÇlectionnÇ Ö la fois. Les autres se
                                        dÇsÇlectionnent automatiquement si l'ont
                                        sÇlectionne un Radio Button qui ne
                                        l'Çtait pas. Le Päre Commun est träs
                                        souvent un G_IBOX (Type 25).
                      BIT 5 : LASTOB : Dernier Objet de l'Arbre. ATTENTION, sous
                                       FORM_DO, on passe d'un champ Çditable Ö
                                       l'autre avec les touches Fleche Haut ou
                                       Bas. Or FORM_DO ne vÇrifie ce BIT
                                       qu'apräs avoir changÇ d'Objet. Donc si
                                       votre dernier Objet est un Champ
                                       Editable, FORM_DO passe Ö l'Objet
                                       suivant, et, Boum...
                      BIT 6 : TOUCHEXIT : Termine la gestion du formulaire. Il
                                          suffit que FORM_DO dÇtecte que cet
                                          Objet est sÇlectionnÇ pour quitter. En
                                          clair, màme pas besoin de relÉcher la
                                          touche de la souris, comme avec EXIT.
                      BIT 7 : HIDETREE : Cache un Objet, et tous ses Fils. Ils
                                         ne seront pas affichÇs avec OBJC_DRAW,
                                         et pas trouvÇs avec OBJC_FIND. Entre
                                         nous, Çvitez ce BIT sur l'objet racine
                                         (numÇro 0).
                      BIT 8 : INDIRECT : Ob_Spec n'est pas utilisÇ directement
                                         (comme Ob_Spec ou comme pointeur), mais
                                         pointe un LONG qui est Ob_Spec (avec
                                         BITs ou pointeur). UtilitÇe : je
                                         cherche encore...
                      BIT 9 : FL3D1
                      BIT A : FL3D2
                              Ces deux BITs donnent une combinaison, qui
                              suivant la valeur donne un certain aspect 3D Ö
                              l'objet:
                              FL3D2 | FL3D1 |
                              ------+-------+----------------------------------
                                0   |   0   | FL3DNONE : Pas d'effet 3D.
                                    |       |            Aspect standard,
                                    |       |            similaire au ST.
                              ------+-------+----------------------------------
                                0   |   1   | FL3DIND : Indicator.
                                    |       |           Donne un aspect bouton
                                    |       |           enfoncÇ ou non.
                                    |       | Exemple : Les boutons des boites
                                    |       |           de dialogues
                              ------+-------+----------------------------------
                                1   |   0   | FL3DBAK : BackGround.
                                    |       |           Donne la couleur de
                                    |       |           fond Ö l'objet.
                                    |       | Utile pour les texte opaques que
                                    |       | l'on veut de la màme couleur que
                                    |       | la boite. Donc en monochrome, le
                                    |       | fond du texte sera blanc, gris en
                                    |       | couleur, au lieu de noir-gris
                              ------+-------+----------------------------------
                                1   |   1   | FL3DACT : Activator.
                                    |       |           Idem que Indicator,
                                    |       |           mais la couleur ne
                                    |       |           change pas une fois
                                    |       |           sÇlectionnÇ.
                                    |       | Exemple : Les boutons des
                                    |       |           fenetres
                              Pour que l'effet 3D apparaisse, il faut que
                              l'objet ait la couleur blanche, et que sont motif
                              de remplissage soit vide...
                      BIT B : SUBMENU : Je sais pas...
                      BITs C Ö F : inutilisÇs
  WORD 5 : Ob_State : Masque de Statut. DÇfinit les caractÇristiques Physique
                      d'un Objet (la tàte qu'il aura Ö l'Çcran). Voici la
                      signification des BITs:
                      BIT 0 : SELECTED : Donne l'Aspet sÇlectionnÇ Ö l'Objet.
                      BIT 1 : CROSSED : Les boite se retrouvent avec une croix
                                        qui forme les diagonales de la boite.
                      BIT 2 : CHECKED : Marque un   dans le coin supÇrieur
                                        gauche de l'Objet.
                      BIT 3 : DISABLED : Affiche l'Objet en grisÇ, et ne peut
                                         plus àtre sÇlectionnÇ
                      BIT 4 : OUTLINED : Les boite ont un deuxiäme cadre
                      BIT 5 : SHADOWED : Les boites projettent une ombre dans le
                                         coin infÇrieur droit. L'Çpaisseur de
                                         cette ombre, ainsi que sont apparente
                                         distance de la boite dÇpendent de
                                         l'Çpaisseur du cadre de la boite.
                      BITs 6 Ö F : InutilisÇs
  LONG 6 : Ob_Spec : SpÇcifications suivant le Type d'Objet (Voir Ob_Type)
                     Contient un champ de BITs ou un pointeur vers une
                     Structure.
  WORD 8 : Ob_X : X du coin supÇrieur gauche (par rapport au Päre, sachant que
                  le Päre de la Racine n'est autre que le Bureau).
  WORD 9 : Ob_Y : Y du coin supÇrieur gauche. Màmes remarques que prÇcÇdemment.
  WORD A : Ob_Width : Largeur de l'Objet
  WORD B : Ob_Height : Hauteur de l'Objet

Juste un appel Ö l'Çquipe de CENTEK : Vous qui àtes en train de programmer
Dolmen, pourquoi ne pas ajouter un G_CIMAGE de Type 34, au format IMG par
exemple? Äa m'aiderait beaucoup pour la prochaine version de SSAV (une idÇe,
comme áa...).

> Structure Ob_Spec
  C'est un champ de BITs sur 32 BITs qui donne la couleur de l'Objet, ainsi que
  des informations sur son cadre s'il en a un.
  BIT 0 Ö 15 : TE_COLOR
    BIT 0 Ö 3 : Couleur Ö l'intÇrieur du cadre
    BIT 4 Ö 6 : Motif de remplissage. C'est une trame monochrome. A 0, il n'y
                en a pas, Ö 7 elle est au maximum, donc remplie.
    BIT 7 : 0 = Texte Transparent (la couleur de fond du texte est transparente
                et laisse voir ce qu'il y a dessous).
            1 = Texte Opaque (la couleur est opaque et recouvre ce qu'il se
                trouvait dessous )
    BIT 8 Ö 11 : Couleur du Texte
    BIT 12 Ö 15 : Couleur du Cadre
  BIT 16 Ö 23 : TE_THICKNESS
    BIT 16 : 0 = Pas de Cadre
             1 = Un cadre
    BIT 17 Ö 23 : Epaisseur du cadre. ATTENTION, ces 7 BITs sont signÇs.
                  1 Ö 127, le cadre va vers l'intÇrieur
                  -1 Ö -127, le cadre va vers l'extÇrieur
                  Ici, pour avoir un nombre correct, recopiez les 8 BITs de
                  TE_THICKNESS dans un registre, et faites :
                    ror.b           #1,Dx
                    btst.b          #6,Dx
                    BEQ             NotNeg
                    bset.b          #7,Dx
    NotNeg          ...
                  Avec un ou deux EXT, vous obtiendrez un superbe nombre signÇ.

> Structure TedInfo
  Contient tous les pointeurs et les informations pour un texte formatÇ
  (regardez, vous comprendrez).
  LONG 0 : TE_PTEXT : Pointeur vers le texte d'entrÇe.
                      Pour exemple, je prendrais celui du "Livre du dÇveloppeur
                      Tome 1" qui est träs parlant :
                      En entrÇe, TE_PTEXT pointe vers 8 espaces. TE_TXTLEN
                      (Voir plus loin) contient 8.
  LONG 2 : TE_PTMPLT : Pointeur vers le masque du texte.
                       C'est une chaåne de caractäre avec masque (_).
                       Ici, pour poursuivre l'exemple prÇcÇdent, TE_PTMPLT
                       pointe vers "Veuillez entrer la date : __/__/____".
  LONG 4 : TE_PVALID : Pointeur vers le masque de validation. Suivant les
                       caractäres contenus, le GEM interdira ou autorisera la
                       saisie d'un type ou plusieurs de caractäres.
                       Toujours pour complÇter l'exemple, TE_PVALID pointe vers
                       "99999999". Ainsi, lorsque ce champs Çditable est
                       traitÇ, l'utilisateur ne peut saisir que des chiffres,
                       qui composeront la date. A la fin du traitement,
                       TE_PTEXT pointe vers les 8 chiffres qui ont remplacÇs
                       les 8 espaces d'origine. Voici les autres masques :
                       9 = Seuls les chiffres sont pris en compte
                       A = Seuls l'espace et le lettres majuscules sont pris en
                           compte
                       a = Seuls l'espace et toutes les lettres (majuscule et
                           minuscule) sont pris en compte
                       N = Seuls l'espace, les majuscules, et les chiffres sont
                           pris en compte
                       n = Seule l'espace, les majuscules, les minuscules, et
                           les chiffres sont pris en compte
                       F = Uniquement les lettres admises dans un nom de fichier
                           valide, ainsi que les Jokers (?*). C'est Ö dire :
                           ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ?*
                           ATTENTION : D'autres caractäres peuvent etres
                                       utilisÇs, mais il est prÇfÇrable de se
                                       limiter Ö l'alphabet et aux chiffres.
                       P = Idem que prÇcÇdemment, mais possibilitÇ d'utiliser
                           les descripteurs de chemin (Path), sans les Jokers,
                           soit ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \:
                       p = Idem, avec les Jokers et les descripteurs de chemins,
                           ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \:?*
                       X = Tout pris en compte.
                         Dans la plupart des Çditeurs de ressource, pour choisir
                       ces attributs, il faut se placer dans la ligne masque, et
                       Çcrire avec la touche Alternate enfoncÇe, plus Shift au
                       besoin. Pour les chiffres, utilisez ceux sous les touches
                       de fonctions, car le pavÇ numÇrique ne marche pas (du
                       moins sous ORCS).
  WORD 6 : TE_FONT : Taille du texte
                     3 = Taille normale
                     5 = Taille "Icones"
  WORD 7 : TE_JUNK1 : RÇservÇ
  WORD 8 : TE_JUST : Justification
                     0 = Le texte sera placÇ Ö gauche
                     1 = Le texte sera placÇ Ö droite
                     2 = Le texte sera centrÇ. Träs courant pour les boutons.
  WORD 9 : TE_COLOR : Couleur de la boite (0 Ö 15)
  WORD A : TE_JUNK2 : RÇservÇ
  WORD B : TE_THICKNESS : Epaisseur du cadre. SignÇ
                          0 = Pas de cadre
                          1 Ö 128 = Cadre vers l'intÇrieur
                          -1 Ö -127 = Cadre vers l'extÇrieur
  WORD C : TE_TXTLEN : Longueur du texte pointÇ par TE_PTEXT
  WORD D : TE_TMPLEN : Longueur du texte pointÇ par TE_PTMPLT

> Structure BitBlk
  Descripteur d'une image sur 6 WORDs.
  LONG 0 : BI_PDATA : Pointeur vers l'image monochrome
  WORD 2 : BI_WB : Largeur en OCTETs de l'image (donc multiple de 8
                   obligatoirement)
  WORD 3 : BI_HL : Hauteur de l'image en points cette fois
  WORD 4 : BI_X : X par rapport au Päre
  WORD 5 : BI_Y : Y par rapport au Päre
  WORD 6 : BI_COLOR : Couleur de l'image (les BITs Ö 1). L'image est
                      transparente, donc les BITs Ö 0 laissent voir le Päre

> Structure UserBlk
  Tableau de 2 LONGs contenant les informations pour l'exÇcution de votre
  routine par l'AES.
  LONG 0 : UB_CODE : Pointeur vers votre routine. Il est hors de question de
                     s'aider de l'AES pour dessiner. Mais le VDI, le GEMDOS, le
                     BIOS, l'XBIOS et les autres sont exploitables.
  LONG 1 : UB_PARM : Votre paramätres sur 32 BITs. Celui-ci sera placÇ dans une
                     Structure au nom de Param, dont l'adresse sera EmpilÇe
                     avant l'appel de votre routine.

> Structure ParamBlk
  Descripteur contenant toutes les informations pour que la routine puisse
  correctement afficher votre dessin Ö l'Çcran, sur 15 WORDs.
  LONG 0 : PB_TREE : Adresse de l'arbre contenant l'Objet "Custom"
  WORD 2 : PB_OBJ : NumÇro de l'Objet ("Custom") qui Ö provoquÇ cette demande
                    d'affichage
  WORD 3 : PB_PREVSTATE : Ancien OB_STATE
  WORD 4 : PB_CURRSTATE : OB_STATE actuel. Si PB_PREVSTATE et PB_CURRSTATE sont
                          identiques, c'est que l'objet en question doit àtre
                          tracÇ, dont l'affichage a ÇtÇ dÇclenchÇ par
                          OBJC_Draw. S'ils sont diffÇrent, c'est qu'il n'y a
                          qu'une demande de rafraåchissement avec OBJC_Change.
  WORD 5 : PB_X : X de l'Objet Ö l'Çcran (et pas par rapport au Päre)
  WORD 6 : PB_Y : Y de l'Objet Ö l'Çcran
  WORD 7 : PB_W : Largeur de l'Objet en points
  WORD 8 : PB_H : Hauteur de l'Objet en points
  WORD 9 : PB_XC : X du CLIPPING
  WORD A : PB_YC : Y du CLIPPING
  WORD B : PB_WC : Largeur du CLIPPING
  WORD C : PB_HC : Hauteur du CLIPPING
  LONG E : PB_PARAM : Votre paramätre prÇcÇdemment contenu dans UB_PARM.

> Structure IconBlk
  Descripteur d'un icìne monochrome sur 17 WORDs.
  LONG 0 : IB_PMASK : Pointeur vers le Masque. Celui-ci DOIT àtre composÇ de
                      WORDs car sa largeur ne peut àtre qu'un multiple de 16
  LONG 2 : IB_PDATA : Idem, mais pour l'image
  LONG 4 : IB_PTEXT : Pointe vers une chaåne de caractäres qui formera le texte
                      de l'icìne
  WORD 6 : IB_CHAR : Caractäre de l'icìne. Par exemple le Nom de l'unitÇ pour
                     l'icìne d'un lecteur
  WORD 7 : IB_XCHAR : X du caractäre par rapport Ö l'icìne
  WORD 8 : IB_YCHAR : Y du caractäre par rapport Ö l'icìne
  WORD 9 : IB_XICON : X de l'icìne par rapport au Päre
  WORD A : IB_YICON : Y de l'icìne par rapport au Päre
  WORD B : IB_WICON : Largeur de l'icìne en points (mais multiple de 16 car les
                      donnÇes sont composÇes de WORDs)
  WORD C : IB_HICON : Hauteur de l'icìne en points
  WORD D : IB_XTEXT : X du texte par rapport Ö l'icìne
  WORD E : IB_YTEXT : Y du texte par rapport Ö l'icìne
  WORD F : IB_WTEXT : Largeur du texte en points
  WORD 10 : IB_HTEXT : Hauteur du texte en points
  WORD 11 : IB_RESVD : RÇservÇ

> Structure CIconBlk
  Descripteur d'un icìne couleur. Il comprend le descripteur IconBlk, plus des
  descripteur pour chaque rÇsolutions.
  IconBlk : Descripteur de l'icìne monochrome sur 17 WORDs.
  CIconPtr : Pointeur vers un premier descripteur CIconBlk :

  CIconBlk : WORD 0 : NUM_PLANES : Nombre de plans de l'icìne (2 pour 4
                                   couleurs, 4 pour 16 couleurs, 8 pour 256
                                   couleurs)
             LONG 2 : COL_DATA : Pointeur vers les donnÇes de l'icìne Ö l'Çtat
                                 Normal, cela au format RASTER (comme l'Çcran,
                                 avec ce fichus entrelacement de plan vidÇo)
             LONG 4 : COL_MASK : Pointeur vers le Masque de l'icìne Normal. Le
                                 masque est en monochrome (1 BIT = 1 point)
             LONG 6 : SEL_DATA : Pointeur vers les donnÇes de l'icìne
                                 SÇlectionnÇ. Voir COL_DATA
             LONG 8 : SEL_MASK : Pointeur vers le Masque de l'icìne
                                 SÇlectionnÇ. Voir COL_MASK
             LONG A : NEXT_RES : Pointeur vers un autre descripteur CIconBlk,
                                 dÇcrivant une autre rÇsolution.
                                 Si ce pointeur est Ö 0, cela signifie qu'il
                                 n'y a plus d'autres rÇsolutions pour cet
                                 icìne.

/// AES  40 : OBJC_ADD ///

Sert Ö additionner un Objet Ö l'arborescence.
  Pour crÇer un nouvel objet ne dÇpendant d'aucun autre, il suffit de prÇciser
comme Objet päre 0, la base de l'arborescence (en gÇnÇral la boite de dialogue
qui contient les diffÇrents Objets). On peut aussi attribuer un nouveau fils Ö
un päre dÇjÖ existant. L'Objet est ajoutÇ en fin d'arborescence, et seul les
pointeurs son changÇs.

Paramätres : LONG : Adresse de l'arborescence (Voir MENU_BAR (AES 30))
             WORD : NumÇro de l'objet päre
             WORD : NumÇro de l'objet fils
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 40
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 16

/// AES  41 : OBJC_DELETE ///

Sert Ö effacer un objet de l'arborescence. Comme áa, carrÇment.
Mais träs logiquement, vous devez vous en douter, efface aussi ses fils (si
l'Objet en a).

Paramätres : LONG : Adresse de l'arborescence (Màme remarque que prÇcÇdemment)
             WORD : NumÇro de l'objet Ö effacer
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 41
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 14

/// AES  42 : OBJC_DRAW ///

Sert Ö dessiner un objet et ses fistons Ö l'Çcran.
  Un CLIPPING est enregistrÇ (Voir VDI 129). C'est seulement dans ce rectangle
que l'objet sera dessinÇ, et c'est seulement lui qui sera effacÇ de l'Çcran
apräs rÇception du message ReDraw du GEM (Voir EVNT_MESAG (AES 23), message de
Type 20 (WM_REDRAW)).
  Cette fonction dÇclenche aussi l'affichage des Objets "Customs" (prÇcision Ö
prÇciser car y'a quelque chose de spÇcial qui se produit pour les Objets Customs
suivant la fonction utilisÇe pour les afficher).

Paramätres : LONG : Adresse de l'arborescence (...)
             WORD : NumÇro de l'objet de dÇpart (0 pour dessiner toute
                    l'arborescence)
             WORD : Niveau maximum dans l'arborescence Ö dessiner. Peut àtre
                    supÇrieur au niveau maximum sans que cela ne pose le
                    moindre probläme, histoire d'àtre certain du bon affichage
                    du formulaire
             WORD : CoordonnÇe X du coin supÇrieur gauche du CLIPPING
             WORD : CoordonnÇe Y du coin supÇrieur droit du CLIPPING
             WORD : Largeur du CLIPPING
             WORD : Hauteur du CLIPPING
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 42
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 24

/// AES  43 : OBJC_FIND ///

Permet de connaåtre exactement le numÇro de l'objet sous la souris.

Paramätres : LONG : Adresse de l'arborescence (...)
             WORD : NumÇro de l'objet de dÇpart (0, c'est la racine)
             WORD : Niveau maximum dans l'arborescence Ö chercher
             WORD : CoordonnÇe X d'un point (par exemple les coordonnÇes de la
                    souris) sous lequel se trouve l'objet Ö chercher
             WORD : CoordonnÇe Y de ce point
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 43
             WORD : 200
Retour : D0.w = NumÇro de l'Objet, sinon -1 si l'Object n'existe pas, ou ne se
                trouve pas dans l'espace de recherche
Pile : 20

/// AES  44 : OBJC_OFFSET ///

Permet de connaåtre prÇcisÇment la position d'un objet (coin supÇrieur gauche)
Ö l'Çcran.

Paramätres : LONG : Adresse de l'arborescence (...)
             WORD : NumÇro de l'objet dont on cherche les coordonnÇes
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 44
             WORD : 200
Retour : D0.l = 0 si erreur, sinon CoordonnÇe X.w et Y.w du coin supÇrieur
                gauche de l'objet
Pile : 14

/// AES  45 : OBJC_ORDER ///

Permet de changer l'ordre des fils d'un Objet päre. Cette fonction doit parfois
àtre appelÇe plusieurs fois de suite pour obtenir un classement correct.
Ce serait sympa de m'aider ici, car toutes les documentations que je possäde ont
une description diffÇrentes entres elles, et je ne peut hÇlas garantir
l'exactitude de mes propos... (ce serait rageant de vous induire en erreur)

Paramätres : LONG : Adresse de l'arborescence (...)
             WORD : NumÇro de l'Objet dont on veut changer de position dans la
                    liste des fils appartenant Ö un Objet päre
             WORD : Nouvelle position (-1 = Premier de la liste
                                        0 = Dernier de la liste
                                        1 = Avant dernier de la liste
                                        2 = Avant avant dernier de la liste)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 45
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 16

/// AES  46 : OBJC_EDIT ///

Sert Ö changer le texte d'un Objet ayant le type G_TEXT ou G_BOXTEXT, ou Ö
saisir un texte dans ce type d'Objet.
Comme MENU_TEXT (AES 34), il est hors de question que le nouveau texte soit plus
long que le prÇcÇdent. Je vous fait pas de dessin s'il vous arrivait ce cas de
figure, le GEM s'en chargera dÇjÖ avec zäle...

Paramätres : LONG : Adresse de l'arborescence (...)
             WORD : NumÇro de l'Objet dont le texte est Ö modifier
             WORD : Caractäre utilisateur
             WORD : Position de dÇpart
             WORD : Fonction (0 = RÇservÇ
                              1 = ED_INIT : Affiche TE_PTEXT (Voit TedInfo) via
                                            TE_PTMPLT, donc en tenant compte du
                                            masque, et avec le curseur
                              2 = ED_CHAR : Controle de validitÇ du caractäre
                                            d'apräs TE_PVALID, le place au bon
                                            endroit dans TE_PTEXT, puis retrace
                                            TE_PTEXT avec ce nouveau locataire
                              3 = ED_END : Efface le curseur)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 46
             WORD : 200
Retour : D0.w = 0 si erreur, sinon nouvelle position du curseur
Pile : 20

/// AES  47 : OBJC_CHANGE ///

Sert Ö changer le statut d'un Objet (OB_STATE). Vous pouvez demander qu'il soit
rÇaffichÇ avec ses nouveau attributs, ou remettre cette opÇration pour la
prochaine fois.
Pour les ÇlÇments du menu, voyez la section Ö ce sujet.

Paramätres : LONG : Adresse de l'arborescence (...)
             WORD : NumÇro de l'Objet Ö modifier
             WORD : CoordonnÇe X du CLIPPING
             WORD : CoordonnÇe Y du CLIPPING
             WORD : Largeur du CLIPPING
             WORD : Hauteur du CLIPPING
             WORD : Nouvel Çtat
             WORD : Mode (0 = Ne re dessine pas ou 1 = Redessine l'objet)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 47
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 28

/// AES  48 : OBJC_SYSVAR ///

  Sert Ö changer la couleur et les attributs 3D d'un objet.

Paramätres : WORD : Mode
                    0 = Information sur les attributs
                    1 = Fixe les nouveaux attributs
             WORD : Combinaison
             WORD : DonnÇes1
             WORD : DonnÇes2
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 48
             WORD : 200
Retour : D0.l = Pointeur vers un tableau
                Structure du tableau : WORD 0 : Retour
                                                0 = Erreur, sinon OK
                                       WORD 1 : DonnÇes1
                                       WORD 2 : DonnÇes2
Pile : 16

--- LIBRAIRIE FORM ---

/// AES  50 : FORM_DO ///

Sert Ö gÇrer un formulaire.
InconvÇnient majeur, tout autre traitement est rendu impossible (passer Ö un
autre formulaire).

Paramätres : LONG : Adresse de l'arborescence Ö gÇrer (...)
             WORD : NumÇro de l'Objet "champ Çditable" Ö gÇrer, sinon -1
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 50
             WORD : 200
Retour : D0.w = NumÇro de l'Objet qui Ö fait quitter le processus de gestion
Pile : 14

REMARQUE : Vous voyez, y'a que 8 lignes Ö Çcrire pour demander au GEM de gÇrer
           son formulaire. Alors oó se trouve la difficultÇ?

/// AES  51 : FORM_DIAL ///

C'est une fonction träs utile qui permet de faire un CLIPPING (mais ne tremblez
donc pas, allez lire ce que j'en dis dans le VDI), de restaurer une partie de
l'Çcran, et de faire des animations inutiles.
  Cette fonction, en dehors des commandes inutiles, doit jouer (car la simple
figuration est superflue) dans votre programme, et àtre prÇsente Ö l'ouverture
et Ö la fermeture d'un formulaire ou d'une fenàtre. Dans le cas d'un formulaire,
mettez 0 dans les 4 premiers paramätres concernant les coordonnÇes (X, Y,
largeur et hauteur au dÇpart).
  Une derniäre chose, pensez toujours Ö effacer tout ce qui se trouve Ö l'Çcran,
et que vous y avez mis, car sous MultiTOS, vu que l'on est sous le bureau en
permanence, celui ci n'est pas rafraåchit Ö la sortie de votre programme, et il
risque de s'y trouver des rÇsidus de formulaire. Regardez au dÇbut de TestSSAV,
le passage par Clr_Before_Quit, pour effacer le premier formulaire. Tachez de ne
pas oublier... De toute maniäre, effacez tout ce que vous dessinez, c'est plus
propre.

Paramätres : WORD : Mode (0 = FMD_START : RÇserve une partie de l'Çcran
                                          (CLIPPING)
                          1 = FMD_GROW : N'est autre que GRAF_GROWBOX (AES 73)
                          2 = FMD_SHRINK : N'est autre que GRAF_SHRINKBOX
                                           (AES 74)
                          3 = FMD_FINISH : Libäre le CLIPPING, mais Ö vous de le
                                           redessiner)
             WORD : CoordonnÇe X du CLIPPING ou de la boite de dÇpart
             WORD : CoordonnÇe Y du CLIPPING ou de la boite de dÇpart
             WORD : Largeur du CLIPPING ou de la boite de dÇpart
             WORD : Hauteur du CLIPPING ou de la boite de dÇpart
             WORD : CoordonnÇe X de la boite de fin
             WORD : CoordonnÇe Y de la boite de fin
             WORD : Largeur de la boite de fin
             WORD : Hauteur de la boite de fin
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 51
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 26

/// AES  52 : FORM_ALERT ///

Permet de gÇrer le plus simplement du monde une boite d'alerte, sans passer par
FORM_DO avec une arborescence sur les bras.
  Träs pratique lorsqu'il s'agit d'avertir notre amis l'utilisateur qu'il serait
temps d'enregistrer son travail et de s'occuper de ses enfants ou de sont
chiens, qui attend patiemment devant la porte avec la laisse entre ses crocs.

Paramätres : WORD : NumÇro du bouton par dÇfaut (0 = Pas de bouton par dÇfaut
                                                 1 = Premier bouton
                                                 2 = Deuxiäme bouton
                                                 3 = Troisiäme bouton)
             LONG : Adresse de la chaåne de message
                    Structure du message : Il est composÇ de trois parties
                      Partie 1 : L'icone (0 = Pas d'icìne
                                          1 = Point d'exclamation
                                          2 = Point d'interrogation
                                          3 = STOP)
                      Partie 2 : Le texte : 5 lignes de 30 caractäres
                      Partie 3 : Le ou les boutons
                      Chaque partie se situe entre deux crochets, et la barre
                      verticale CHR$(124) sÇpare les ÇlÇments d'une màme partie
                      Ex : [3][Ceci est un test|de boite d'Alerte][Oui|Non]
                           affiche une boite d'alerte avec un icìne STOP, deux
                           lignes de texte, et deux boutons.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 52
             WORD : 200
Retour : D0.w = NumÇro du bouton cliquÇ
Pile : 14

/// AES  53 : FORM_ERROR ///

Sert Ö afficher rapidement une boite d'erreur correspondant Ö un code d'erreur
du GEM.
  Ainsi, si vous venez de recevoir ce code, offrez le gracieusement Ö
l'utilisateur via cette fonction pour lui signaler sont erreur.

Voici les codes d'erreurs et les textes affichÇs :
Code 2, 3, 18 : "Cette application ne peut pas trouver l'objet auquel vous
                 essayez d'accÇder."
Code 4 : "Cette application n'a pas suffisamment de place pour ouvrir un autre
          document. Fermez un document que vous n'utilisez pas."
Code 5 : "Un objet ayant ce nom existe dÇjÖ, ou bien il n'autorise pas
          l'Çcriture."
Code 8, 10, 11 : "MÇmoire insuffisante pour l'application en cours."
Code 15 : "Le lecteur spÇcifiÇ n'existe pas."
Les autres Code : "Erreur TOS #n", avec n le code de l'erreur

Paramätres : WORD : NumÇro de l'erreur a simuler
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 53
             WORD : 200
Retour : D0.w = NumÇro du bouton cliquÇ
Pile : 10

/// AES  54 : FORM_CENTER ///

Permet d'obtenir la position centrÇe d'un arbre.
A utiliser absolument avant le premier traitement avec FORM_DIAL ou OBJC_DRAW.
  Apräs, une fois tracÇ et dÇplacÇ, utilisez des variables pour retracer l'arbre
Ö des positions dÇfinis par l'utilisateur. Les coordonnÇes renvoyÇes sont utiles
pour le CLIPPING, sans plus, car FORM_CENTER change les coordonnÇes de l'Objet
Päre (le premier Objet qu'il trouve en principe), qui sera centrÇ par la suite.

Paramätres : LONG : Adresse de l'arborescence (...)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 54
             WORD : 200
Retour : D0.l = Pointeur sur un tableau contenant les coordonnÇes de l'objet
                une fois centrÇ Ö l'Çcran
                Structure du tableau : WORD 0 : CoordonnÇe X
                                       WORD 1 : CoordonnÇe Y
                                       WORD 2 : Largeur
                                       WORD 3 : Hauteur
Pile : 12

/// AES  55 : FORM_KEYBD ///

(Pas documentÇ, mais implantÇ)

Paramätres : LONG : Adresse
             WORD : Objet Päre
             WORD : Objet Fils
             WORD : Caractäre
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 55
             WORD : 200
Retour : D0.w = Int_Out0
Pile : 18

/// AES  56 : FORM_BUTTON ///

(Pas documentÇ, mais implantÇ)

Paramätres : LONG : Adresse
             WORD : Objet
             WORD : Nombre
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 56
             WORD : 200
Retour : D0.w = Int_Out0
Pile : 16

--- LIBRAIRIE GRAPHIQUES ---

/// AES  70 : GRAF_RUBBERBOX ///

Sert Ö afficher et Ö changer la taille d'une boite avec la souris.
  Cette fonction se termine si le bouton gauche de la souris n'est pas ou plus
pressÇ. Donc si vous appelez cette fonction sans que le bouton gauche soit
pressÇ, vous revenez illico Ö votre programme.

Paramätres : WORD : CoordonnÇe X du coin supÇrieur gauche de la boite
             WORD : CoordonnÇe Y du coin supÇrieur gauche de la boite
             WORD : Largeur de la boite
             WORD : Hauteur de la boite
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 70
             WORD : 200
Retour : D0.l = 0 si erreur, sinon Largeur.w et Hauteur.w
Pile : 16

/// AES  71 : GRAF_DRAGBOX ///

Sert Ö dÇplacer une boite Ö l'aide de la souris dans un rectangle.
Comme prÇcedemment, cette fonction se termine au relÉchement du bouton gauche.

Paramätres : WORD : Largeur de la boite en points
             WORD : Hauteur de la boite en points
             WORD : X de dÇpart de la boite
             WORD : Y de dÇpart de la boite
             WORD : X du rectangle d'action
             WORD : Y du rectangle d'action
             WORD : Largeur du rectangle d'action
             WORD : Hauteur du rectangle d'action
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 71
             WORD : 200
Retour : D0.l = 0 si erreur, sinon X.w et Y.w de la boite au relÉchement du
                bouton gauche
Pile : 24

/// AES  72 : GRAF_MOVEBOX ///

Sert Ö faire dÇplacer une boite toute seule, comme une grande.

Paramätres : WORD : Largeur de la boite en points
             WORD : Hauteur de la boite en points
             WORD : X de dÇpart de la boite
             WORD : Y de dÇpart de la boite
             WORD : X de fin de la boite
             WORD : Y de fin de la boite
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 72
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 20

/// AES  73 : GRAF_GROWBOX ///

Dessine une "boite" qui grandit. UtilitÇ discutable.
Vous savez, c'est les petites lignes qui s'animent lorsque vous ouvrez un
lecteur sous le bureau, juste avant l'ouverture de la fenàtre, par exemple.

Paramätres : WORD : X de dÇpart de la boite
             WORD : Y de dÇpart de la boite
             WORD : Largeur de dÇpart de la boite en points
             WORD : Hauteur de dÇpart de la boite en points
             WORD : X fin de la boite
             WORD : Y fin de la boite
             WORD : Largeur finale de la boite en points
             WORD : Hauteur finale de la boite en points
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 73
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 24

/// AES  74 : GRAF_SHRINKBOX ///

Dessine une "boite" qui rÇtrÇcit. Idem, si vous avez deux secondes devant vous,
Ö perdre... (or le temps c'est de l'argent, et tout le monde le sait).

Paramätres : WORD : X fin de la boite
             WORD : Y fin de la boite
             WORD : Largeur finale de la boite en points
             WORD : Hauteur finale de la boite en points
             WORD : X de dÇpart de la boite
             WORD : Y de dÇpart de la boite
             WORD : Largeur de dÇpart de la boite en points
             WORD : Hauteur de dÇpart de la boite en points
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 74
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 24

/// AES  75 : GRAF_WATCHBOX ///

Cette fonction change l'aspect d'une boite suivant deux facteurs :
 - La position de la souris (hors ou sur la boite)
 - L'Çtat du bouton gauche (enfoncÇ ou pas)
Sert par exemple si vous sÇlectionnÇ un bouton, mais sans relÉcher le bouton
gauche, vous sortez de la boite. Vous pouvez donc dÇfinir deux Çtats.
  Il est träs courant Ö ce niveau de mettre l'Çtat sÇlectionnÇ si la souris se
trouve au dessus de la boite, et dÇsÇlectionnÇ si la souris ne l'est pas. Permet
par exemple de revenir sur sa dÇcision si l'on change d'avis alors que l'on Ö
sÇlectionnÇ le bouton. Il suffit de sortir de la boite, et de relÉcher.
  Mais en fait, c'est Ö vous de gÇrer cela. Cette fonction est lÖ plutìt Ö titre
d'embellissement. FORM_DO utilise d'ailleurs cette fonction. Vous pouvez essayer
sous un de vos formulaire, ou tout autre programme (TestSSAV).

Paramätres : LONG : Adresse de l'arbre
             WORD : NumÇro de l'objet
             WORD : Aspect lorsque la souris est au dessus de la boite
                    BIT 0 : Normal
                    BIT 1 : Selected
                    BIT 2 : Crossed
                    BIT 3 : Checked
                    BIT 4 : Disabled
                    BIT 5 : OutLined
                    BIT 6 : Shadowed
             WORD : Aspect lorsque la souris est hors de la boite
                    Idem que prÇcedemment
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 75
             WORD : 200
Retour : D0.w = Position de la souris au relÉchement du bouton gauche
                0 = Hors de la boite
                1 = Au dessus de la boite
Pile : 18

/// AES  76 : GRAF_SLIDEBOX ///

Permet de faire glisser une boite avec la souris dans sa boite Märe. Comme
prÇcedemment, la fonction se termine au relÉchement du bouton gauche.
  Lors de la rÇception du rÇsultat, faite un BCLR sur le bit 15. Vous pourrez
savoir de quel type de dÇplacement il s'agissait, et vous pourrez ainsi utiliser
le rÇsultat qui sera ainsi compris entre 0 et 1000, comme il doit l'àtre.

Paramätres : LONG : Adresse de l'arbre
             WORD : NumÇro du Päre (ou de la Märe dans ce cas)
             WORD : NumÇro de l'Objet par rapport Ö la Racine
             WORD : Direction de dÇplacement
                    0 = Horizontale
                    1 = Verticale
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 76
             WORD : 200
Retour : D0.w = Postion de l'Objet par rapport Ö son Päre. Cette position
                s'apparente Ö celle des "Cabines" des ascenseurs.
                0 = Tout en haut s'il s'agissait d'un dÇplacement Vertical
                    Tout Ö gauche s'il s'agissait d'un dÇplacement Horizontal
                1000 = Tout en bas s'il s'agissait d'un dÇplacement Vertical
                       Tout Ö droite s'il s'agissait d'un dÇplacement Horizontal
                BIT 15 = 0 : s'il s'agissait d'un dÇplacement Horizontal
                         1 : s'il s'agissait d'un dÇplacement Vertical
Pile : 18

/// AES  77 : GRAF_HANDLE ///

Permet d'obtenir le Handle VDI du bureau courant, et des informations sur la
fonte actuelle.
Avec cela, et un Extended Inquire Function (VDI 102) bien sentit, vous pouvez
obtenir toutes les informations dont vous avez besoin.

Paramätres : LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 77
             WORD : 200
Retour : D0.l = Pointeur vers un tableau contenant les informations
                Structure du tableau : WORD 0 : Handle du VDI
                                       WORD 1 : Largeur d'un caractäre en
                                                points
                                       WORD 2 : Hauteur d'un caractäre en
                                                points
                                       WORD 3 : Largeur d'une cellule en points
                                       WORD 4 : Hauteur d'une cellule en points
Pile : 8

/// AES  78 : GRAF_MOUSE ///

Permet de changer la forme de la souris.
Il est souhaitable d'appeler cette fonction juste apräs votre APPL_INIT, car
sinon la souris reste sur la forme de l'abeille, signe de chargement. Ce n'est
pas le GEM qui s'en charge, car rien ne vous empàche au dÇbut de votre programme
de continuer Ö charger des fichiers complÇmentaires, et de signaler Ö
l'utilisateur que l'ordinateur n'a pas fini son chargement en laissant la souris
sous forme d'abeille.
  De plus, tachez d'avoir la forme de la fleche lorsque vous quittez une
application.

Paramätres : WORD : Code du dessin
                      0 = Fläche normale
                      1 = Curseur Texte (Barre verticale)
                      2 = Abeille
                      3 = Main fermÇe avec doigt tendu
                      4 = Main ouverte
                      5 = RÇticule fin
                      6 = RÇticule Çpais (Un grand + noir)
                      7 = RÇticule encadrÇ (Un grand + OutLined)
                    255 = Forme dÇfinit par l'utilisateur
                    256 = Supprime la souris
                    257 = RÇussusite la souris
                          ATTENTION : Vous devez rÇssusiter la souris autant de
                                      fois que vous l'avez supprimÇ avant
                                      qu'elle ne rÇapparaisse. Voyez pourquoi
                                      dans le chapitre sur la LineA (les
                                      variables systäme)
                    258 = Sauve la forme actuelle
                    259 = Restaure la derniere forme sauvegardÇe
                    260 = Restaure la forme prÇcÇdente
             LONG : Adresse d'une structure UserMouse
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 78
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 14

> Structure UserMouse
  Cette structure contient les informations relative au nouveau pointeur de la
  souris.
  WORD 0 : MF_XHOT : X du "Point Chaud". C'est le "Point Chaud" qui agit sur
                     les diffÇrents ÇlÇments du GEM. Il est compris entre 0 et
                     15, car la souris fait 16 pixels de haut et de large.
  WORD 1 : MF_YHOT : Y du "Point Chaud"
  WORD 2 : MF_NPLANES : Ben... TOUJOURS Ö 1, car le pointeur est TOUJOURS
                        monochrome, mais les programmeurs de Digital Research
                        sont prÇvoyants. Rien ne vous empàche d'Çcrire votre
                        propre routine de traitement de la souris, et donc
                        d'utiliser cette donnÇe pour en faire une en couleur.
  WORD 3 : MF_FG : Couleur du masque. Mettez 0 (Blanc).
  WORD 4 : MF_BG : Couleur du dessin. Mettez 1 (Noir)
  WORD 5 : MF_MASK : 16 WORDs reprÇsentant le masque du pointeur
  WORD 15 : MF_DATA : 16 WORDs reprÇsentant le dessin du pointeur

  Si ATARI a prÇvus de pouvoir sauvegarder la forme de la souris, c'est pour le
multitache. En effet, imaginez que l'application actuelle fasse une lecture
disque, et que la souris soit changÇe en "Abeille". Pendant ce temps, vous
 voulez
faire un Drag'n Drop sur l'application en arriere plan. Il sagit donc de
changer la souris en "Main Plate", d'effectuer votre transfert, et une fois
fini, de restaurer la forme prÇcÇdente, en l'occurence une "Abeille".

/// AES  79 : GRAF_MKSTATE ///

Fournit plein de petites informations sur la souris. Jetez un oeil Ö
EVNT_MOUSE (AES 22), mais n'oubliez pas de le reprendre, sinon áa fait nÇgligÇ.

Paramätres : LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 79
             WORD : 200
Retour : D0.l = Pointeur vers un tableau resplendissant, tant il contient de
                chose utile (j'entend dÇjÖ McGyver japper et piaffer de plaisir)
                Structure du tableau : WORD 0 : 1 (doze, treize...)
                                       WORD 1 : X de la souris
                                       WORD 2 : Y de la souris
                                       WORD 3 : Etat des boutons
                                                BIT 0 : Bouton gauche
                                                BIT 1 : Bouton droit
                                       WORD 4 : Etat des touches spÇciales
                                                BIT 0 : SHIFT droit
                                                BIT 1 : SHIFT gauche
                                                BIT 2 : CONTROL
                                                BIT 3 : ALTERNATE
Pile : 8

--- LIBRAIRIE SCRAP ---

/// AES  80 : SCRP_READ ///

Lit le chemin du ClipBoard actuel.
Encore faut il que celui ci ait ÇtÇ dÇfinit par SCRP_WRITE (AES 81). Le tampon,
faites le assez grand, mais pas trop (256 OCTETs suffisent), car le chemin ne
doit comporter que le lecteur et le nom du rÇpertoire.

Paramätres : LONG : Adresse du tampon pour recevoir le chemin du ClipBoard
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 80
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 12

/// AES  81 : SCRP_WRITE ///

Sert Ö fixer le chemin correct du ClipBoard. Le nom du rÇpertoire DOIT àtre
"CLIPBRD", et rien d'autre, PigÇ? De plus, le chemin du rÇpertoire DOIT se
terminer par "\" et un OCTET nul.
Vous me direz : "C'est idiot de redÇfinir le chemin d'accäs au dossier ClipBoard
Ö chaque lancement d'un programme", mais bon, vaut mieux deux fois que pas du
tout.

Paramätres : LONG : Adresse du rÇpertoire
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 81
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 12

--- LIBRAIRIE SELECTEURS DE FICHIER ---

/// AES  90 : FSEL_INPUT ///

C'est le sÇlecteur de fichier Standard.
  Youpi, mais il nÇcessite environ 16 Ko de libre dans la mÇmoire pour
fonctionner, sinon, rien ne se passe, histoire de vous laisser libÇrer de la
mÇmoire et de le resiffler.
  De plus, il semble fortement que le sÇlecteur de fichier soit gÇrÇ Ö la
 maniäre
de FORM_DO, car vous ne pouvez en sortir que par voie lÇgale (les boutons).
C'est bien dommage d'ailleurs.

Paramätres : LONG : Adresse du rÇpertoire de dÇpart, avec masque
             LONG : Adresse du nom du fichier qui apparaåtra au dÇpart, mais
                    que l'on peut changer par la suite. Le nom de ce fichier
                    sera remplacÇ par le nouveau si vous appuyez sur "O-KAY"
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 90
             WORD : 200
Retour : D0.l = 0 si erreur, sinon le WORD de poids fort contient soit :
                  0 = Bouton "AnnulÇ"
                  1 = Bouton "OK"
Pile : 16

/// AES  91 : FSEL_EXINPUT ///

La grande Star (cris de foule, trompette, choeur d'enfants, ...). Idem que
prÇcÇdemment (sifflements, ...), mais l'on peut donner le titre que l'on dÇsir
au sÇlecteur (soupirs de soulagement, ...).
  Certains n'en verront pas l'utilitÇ, mais imaginez que vous avez programmez un
traitement de texte, et que dans le menu, l'option de chargement et de
sauvegarde soient juxtaposÇs. Si l'utilisateur ne fait pas attention, il risque
de choisir l'option "Sauver" au lieu de "Charger", et ainsi, sans le savoir,
Çcraser, avec le texte qu'il est en train d'Çditer, le texte qu'il voulait
charger.
  Donc, avec ce sÇlecteur, vous pouvez vÇritablement indiquer Ö l'utilisateur
l'option qu'il a choisit, et en cas d'erreur, il peut revenir en arriäre avant
de commettre l'irrÇparable. Cependant, cette fonction ne fonctionne qu'Ö partir
du TOS 1.4, Arghh...

Paramätres : LONG : Adresse du rÇpertoire de dÇpart, avec masque
             LONG : Adresse du nom du fichier
             LONG : Adresse du titre du sÇlecteur (pas plus de 30 caractäres)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 91
             WORD : 200
Retour :  D0.l = 0 si erreur, sinon le WORD de poids fort contient soit :
                   0 = Bouton "AnnulÇ"
                   1 = Bouton "OK"
Pile : 20

--- LIBRAIRIE FENETRES ---

/// AES 100 : WIND_CREATE ///

Sert Ö crÇer une fenàtre pour qu'elle soit gÇrÇe par l'AES.
  A sa crÇation, la fenàtre n'est pas ouverte, mais existe, et peut l'àtre par
l'appel de la fonction WIND_OPEN (AES 101).

Paramätres : WORD : Champ de BITs dÇfinissant la tàte qu'aura la fenàtre.
                    BIT 0 : Barre de Titre
                    BIT 1 : Closer - Bouton au coin supÇrieur gauche pour
                            fermer la fenàtre
                    BIT 2 : Fuller - Bouton au coin supÇrieur droit pour
                            ouvrir la fenàtre sur tout le bureau
                    BIT 3 : Barre de dÇplacement - En fait, la Barre de Titre,
                            mais indique Ö l'AES que l'on dÇsire que cette
                            fenàtre soit dÇplaáable
                    BIT 4 : Info - La ligne d'informations juste sous la Barre
                            de Titre
                    BIT 5 : Sizer - Le bouton au coin infÇrieur droit pour
                            modifier la taille de la fenàtre
                    BIT 6 : UpArrow - La fläche vers le haut
                    BIT 7 : DnArrow - La fläche vers le bas
                    BIT 8 : VSlide - La "cabine" verticale, ainsi que
                            l'ascenseur
                    BIT 9 : LfArrow - La fläche vers la gauche
                    BIT A : RtArrow - La fläche vers la droite
                    BIT B : HSlide - La "cabine" horizontale, ainsi que le
                            couloir
             WORD : X de la fenàtre
             WORD : Y de la fenàtre
             WORD : Largeur de la fenàtre
             WORD : Hauteur de la fenàtre
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 100
             WORD : 200
Retour : D0.w = Handle de la fenàtre crÇe
Pile : 18

/// AES 101 : WIND_OPEN ///

Sert Ö faire apparaåtre la fenàtre avec la taille dÇfinie.

Paramätres : WORD : Handle de la fenàtre que l'on souhaite ouvrir
             WORD : X de la fenàtre
             WORD : Y de la fenàtre
             WORD : Largeur de la fenàtre
             WORD : Hauteur de la fenàtre
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 101
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 18

WIND_OPEN
Voila, c'est áa quand on ne travaille pas comme moi, toujours Ö repomper les
memes erreurs. Un trop celebre fabriquant de processeur en connait quelque
chose, d'avoir assurÇ avec zele la compatibilite ascendante des bugs de son
bÇbÇ, qu'on Ö la joie de retrouver du premier au dernier. Vous savez, celui qui
bouffe autant d'energie que son systeme de refroidissement. Aussi intelligent
que d'installer sa plaque chauffante dans le congelateur. Bah, l'erreur est
humaine... Et que les patch qui ralentissent le processeur existe.

/// AES 102 : WIND_CLOSE ///

Sert Ö fermer une fenàtre. NÇanmoins, celle ci existe toujours en mÇmoire, et
peut àtre Ö tout moment rÇouverte. Attendez vous apräs cette fonction Ö recevoir
une sÇrie de messages de Redraw, histoire de redessiner ce que la fenàtre avait
recouvert.

Paramätres : WORD : Handle de la fenàtre Ö fermer
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 102
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 10

/// AES 103 : WIND_DELETE ///

Indique Ö l'AES que l'on dÇsire dÇtruire une fenàtre qui ne nous servira plus.
Il s'agit aussi de dÇtruire toutes les fenàtres crÇes avant de quitter le
programme. Si vous disposez d'un TOS rÇcent, utilisez WIND_NEW (AES 109), il
fait tout.

Paramätres : WORD : Handle de la fenàtre Ö dÇtruire
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 103
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 10

/// AES 104 : WIND_GET ///

Sert Ö obtenir un tas d'informations sur une fenàtre. DÇpend aussi de se que
vous voulez comme renseignements.

Paramätres : WORD : Handle de la fenàtre
             WORD : Informations demandÇes
                    4 = WF_WORKXYWH : Position et dimension de la zone de
                                      travail de la fenàtre, c'est Ö dire oó
                                      apparaåt le texte ou le dessin, sans
                                      compter les ÇlÇments de la fenàtre
                                      WORD 0 : X
                                      WORD 1 : Y
                                      WORD 2 : Largeur
                                      WORD 3 : Hauteur
                    5 = WF_CURRXYWH : Position et dimensions de la fenàtre
                                      WORD 0 : X
                                      WORD 1 : Y
                                      WORD 2 : Largeur
                                      WORD 3 : Hauteur
                    6 = WF_PREVXYWH : Idem, mais pour sa prÇcÇdente position et
                                      taille (utile pour faire revenir la
                                      fenàtre dans sa position initiale sans
                                      utiliser de variables)
                                      WORD 0 : X
                                      WORD 1 : Y
                                      WORD 2 : Largeur
                                      WORD 3 : Hauteur
                    7 = WF_FULLXYWH : Idem, mais pour la taille maximale (pour
                                      un Full sur le bureau)
                                      WORD 0 : X
                                      WORD 1 : Y
                                      WORD 2 : Largeur
                                      WORD 3 : Hauteur
                    8 = WF_HSLIDE : Position de la "Cabine" horizontale
                                    WORD 0 : Position
                    9 = WF_VSLIDE : Position de la "Cabine" verticale
                                    WORD 0 : Position
                    10 = WF_TOP : Handle de la fenàtre en premier plan
                                  WORD 0 : Handle
                    11 = WF_FIRSTXYWH : Position et dimension du premier
                                        rectangle dans la liste "Intersection".
                                        C'est grÉce Ö cette liste que vous allez
                                        pouvoir demander au GEM de redessiner
                                        morceaux par morceaux  les ÇlÇments de
                                        l'Çcran effacÇs par votre fenàtre ou
                                        formulaire.
                                          Il faut utiliser cette fonction apräs
                                        un message de Redraw pour obtenir une
                                        liste de rectangles qu'il faudra
                                        demander de redessiner.
                                          Ici, on commence par demander le
                                        premier rectangle (un peu comme F_SFIRST
                                        et F_SNEXT du GEMDOS). Dans le message
                                        de Redraw, vous recevez la position et
                                        la dimension d'une zone rectangulaire.
                                        C'est celle prÇcÇdemment ClippÇ. Avec
                                        WF_FIRSTXYWH, vous obtenez de petits
                                        rectangles, qui correspondent aux
                                        vÇritables zones Ö redessiner. Mais il
                                        ne s'agit pas d'omettre les coordonnÇes
                                        et les dimensions envoyÇes par le
                                        message de Redraw.
                                          Il ne faut redessiner que les parties
                                        communes de ce rectangle, et les petits
                                        rectangles de WF_FIRSTXYWH. Ca peut vous
                                        paraåtre abscons Ö la premiäre lecture,
                                        mais je vous invite Ö vous rÇfÇrer Ö
                                        l'article de Mr ATTARD sur ce sujet,
                                        parus dans le numÇro 80 d'ST MAGAZINE.
                                          Je peut fournir des photocopies contre
                                        5 francs (porc [Groã?] compris).
                                        WORD 0 : X
                                        WORD 1 : Y
                                        WORD 2 : Largeur
                                        WORD 3 : Hauteur
                    12 = WF_NEXTXYWH : Position et taille des autres rectangles,
                                       un par appel, jusqu'a obtention d'une
                                       taille nulle (plus de rectangles Ö
                                       redessiner).
                                       WORD 0 : X
                                       WORD 1 : Y
                                       WORD 2 : Largeur
                                       WORD 3 : Hauteur
                    15 = WF_HSLSIZE : Taille de la "Cabine" horizontale. -1 est
                                      la taille minimum, sinon c'est entre 1 et
                                      1000 pour les raisons que vous connaissez.
                                      WORD 0 : Taille
                    16 = WF_VSLSIZE : Taille de la "Cabine" verticale. Idem que
                                      prÇcedemment.
                                      WORD 0 : Taille
                    17 = WF_SCREEN : J'ai pas de doc explicite, mais d'apräs le
                                     livre du dÇveloppeur, vous obtenez dans
                                     LONG 0 : Adresse du tampon ALERT
                                     WORD 2 : Largeur
                                     WORD 3 : Hauteur
                                     Il s'agirait d'un buffer qui doit
                                     normalement avoir la taille d'un quart de
                                     l'Çcran pour y ranger le fond lors de
                                     l'ouverture d'un menu dÇroulant ou d'une
                                     boite d'alerte, histoire que le GEM n'ait
                                     pas Ö vous envoyer de message de ReDraw
                                     apräs vous avoir saccagÇ le bureau.
                                       C'est pas propre, mais áa marche. Et pis
                                     c'est rapide, en plus...
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 104
             WORD : 200
Retour : D0.l = 0 si erreur, sinon pointeur sur un tableau contenant les
                informations demandÇes
                Structure du tableau : Regardez dans les Informations
                                       sollicitÇes
Pile : 12

/// AES 105 : WIND_SET ///

Sert Ö changer les attributs d'une fenàtre. Il s'agira de la redessiner par la
suite.

Paramätres : WORD : Handle de la fenàtre Ö retoucher
             WORD : Attributs Ö changer
                    1 = WF_KIND : Les attributs de la fenàtre
                                  In1 : Nouveaux attributs comme WIND_CREATE
                                  BIT 0 : Barre de Titre
                                  BIT 1 : Closer - Bouton au coin supÇrieur
                                          gauche pour fermer la fenàtre
                                  BIT 2 : Fuller - Bouton au coin supÇrieur
                                          droit pour ouvrir la fenàtre sur tout
                                          le bureau
                                  BIT 3 : Barre de dÇplacement - En fait, la
                                          Barre de Titre, mais indique Ö l'AES
                                          que l'on dÇsire que cette fenàtre
                                          soit dÇplaáable
                                  BIT 4 : Info - La ligne d'informations juste
                                          sous la Barre de Titre
                                  BIT 5 : Sizer - Le bouton au coin infÇrieur
                                          droit pour modifier la taille de la
                                          fenàtre
                                  BIT 6 : UpArrow - La fläche vers le haut
                                  BIT 7 : DnArrow - La fläche vers le bas
                                  BIT 8 : VSlide - La "cabine" verticale, ainsi
                                          que l'ascenseur
                                  BIT 9 : LfArrow - La fläche vers la gauche
                                  BIT A : RtArrow - La fläche vers la droite
                                  BIT B : HSlide - La "cabine" horizontale,
                                          ainsi que le couloir
                    2 = WF_NAME : Titre de la fenàtre
                                  In1 et In2 : Adresse de la chaåne de caractäre
                                               du Titre de la fenàtre.
                                               Cependant, l'AES prend l'adresse,
                                               et non la chaåne de caractäres,
                                               donc il ne faut surtout pas
                                               changer cette chaåne de caractäre
                                               tant que la fenàtre est ouverte
                    3 = WF_INFO : Ligne d'infos de la fenàtre
                                  In1 et In 2 : Adresse de la chaåne de
                                                caractäres de la ligne d'Infos.
                                                Màmes remarques que prÇcÇdemment
                    5 = WF_CURRXYWH : Fixe la nouvelle position et taille de la
                                      fenàtre
                                      In1 : X
                                      In2 : Y
                                      In3 : Largeur
                                      In4 : Hauteur
                    8 = WF_HSLIDE : Fixe la position de la "Cabine" horizontale
                                    In1 : Position
                                    La position est simple Ö calculer, 0 Çtant
                                    le dÇpart et 1000 la fin (attention,
                                    derniäre page, donc calculez le nombres de
                                    lignes dans cette page). La position est
                                    donc Çgale Ö :
                                    (NumÇro de la premiäre ligne affichÇe /
                                    (NumÇro de la derniäre ligne - Nombre de
                                     lignes par page))*1000
                    9 = WF_VSLIDE : Idem pour la "Cabine" verticale
                                    In1 : Position
                                    Idem que prÇcedemment.
                    10 = WF_TOP : Fait venir la fenàtre au premier plan
                    14 = WF_NEWDESK : Fixe un nouveau menu (avec nouvelle barre
                                      de menu). Cependant, avant de quitter,
                                      appeler cette fonction avec comme
                                      paramätre 0 pour que le menu du GEM s'y
                                      remette.
                                        Facultatif cependant, car le GEM, Ö la
                                      sortie d'un programme, reprend le bureau).
                                      Peut àtre pour forcer MultiTOS Ö
                                      rafraåchir l'Çcran Ö la sortie
                                      In1 et In2 : Adresse de l'arbre
                                      In3 : NumÇro du premier Objet Ö dessiner
                    15 = WF_HSLSLIDE : Fixe la taille de la "Cabine" horizontale
                                       In1 : Taille
                                       Sachant que la taille de la cabine est
                                       proportionnelle Ö la taille du document
                                       affichÇ, la longueur du couloir est en
                                       principe de 1000+Taille de la Cabine.
                                       Pour calculer cette taille, prenez la
                                       formule magique de Mr ATTARD, c'est Ö
                                       dire :
                                       (1000* Largeur AffichÇe)/Largeur Totale.
                                       Ainsi, si le document est entiärement
                                       affichÇ, la taille vaut 1000, et la
                                       moitiÇ si la largeur affichÇe est deux
                                       fois moindre.
                    16 = WF_VSLSLIDE : Fixe la taille de la "Cabine" verticale
                                       In1 : Taille
                                       Màme rÇsonnement que prÇcedemment.
             WORD : In1, Ö 0 si inutilisÇ
             WORD : In2, idem
             WORD : In3, idem
             WORD : In4, idem
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 105
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 20

ATTENTION : Lors des calcul pour la position ou la taille en rapport avec les
            ascenseurs des fenàtres, de travailler avec le plus de prÇcision
            possible, pour Çviter les pertes, vu que vous travaillez sur des
            entiers, en gÇnÇral. Äa permet d'Çviter les stupides erreurs
            d'arrondis (grossiers dans ce cas de figure).
              D'ordinaire, c'est avec des WORDs que l'on travaille, mais rien ne
            doit vous empàcher d'utiliser les services du coprocesseur si vous
            le trouvez dans la configuration (voyez le Cookie _FPU). Les
            nouveaux processeurs comme le 68030 peuvent faire des divisions sur
            des LONGs.

/// AES 106 : WIND_FIND ///

Sert Ö obtenir le Handle de la fenàtre qui se trouve sous une position donnÇe.
  En gÇnÇral (Oui? Ici DEUG-HOLE en direct de Colombe-hait-les-deux-Çglise), on
prend celle de la souris, histoire de mettre en avant plan un fenàtre recouverte
par d'autres.

Paramätres : WORD : X de la position donnÇe
             WORD : Y de la position donnÇe
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 106
             WORD : 200
Retour : D0.w = Handle de la fenàtre
Pile : 12

/// AES 107 : WIND_UPDATE ///

Sert Ö signaler Ö l'AES que vous allez entreprendre la fastidieuse aventure de
travailler sur votre fenàtre, et qu'il serait souhaitable qu'il ne touche plus
au bureau le temps que vous ayez fini. Permet aussi de prendre le contrìle Ö la
main de la souris.
C'est utile pour une copie raster dans l'Espace de Travail de la fenàtre (pour
afficher une image dans une fenàtre, donc).

Paramätres : WORD : Code de commande
                    0 : END_UPDATE : Vous avez fini de travailler, et vous
                                     indiquez Ö l'AES qu'il peut continuer sont
                                     travail.
                    1 : BEG_UPDATE : Vous commencez, et vous dÇsirer ne plus
                                     voir Ö l'Çcran un menu s'ouvrir
                                     intempestivement sur votre dessin que vous
                                     àtes en train de recopier directement Ö
                                     l'Çcran (ce qui n'est fortement pas
                                     conseillÇ, passez par une fonction du VDI
                                     comme Copy Raster (VDI 109 ou 121).
                    2 : END_MCTRL : Vous avez fini de faire joujou avec la
                                    souris, et vous demandez Ö l'AES qu'il la
                                    reprenne dans son Çlevage, pour qu'elle
                                    arràte de vous couiner dans les oreilles
                    3 : BEG_MCTRL : Vous prennez la souris par la queue, et vous
                                    pouvez l'assaisonner Ö la sauce APPL_TPLAY,
                                    histoire de lui faire faire un parcours
                                    qu'elle Ö dÇjÖ effectuÇe, ou tout autre
                                    chose.
                                      Sert surtout Ö la bloquer pour Çviter
                                    qu'elle ne laisse des traces de son passage
                                    sur votre chef-d'oeuvre. En principe, le
                                    tampon ALERT n'est plus en fonction vu que
                                    le GEM est dÇconnectÇ. Vous pouvez
                                    l'utiliser comme bon vous semble,
                                    thÇoriquement (d'apräs Le Livre Du
                                    Developpeur). J'ai jamais tentÇ cet exercice
                                    de haute voltige sans filet, alors
                                    attention. D'ailleurs, justement, ...
                                    ATTENTION : C'est Ö vous de tout gÇrer, le
                                                GEM est parti en vacance. Les
                                                menus ne marchent plus, la
                                                souris ne rÇpond plus (utilisez
                                                donc votre super routine de
                                                gestion de la souris - Voyez la
                                                LineA).
                                                  N'essayez donc PAS d'attendre
                                                certains messages ou boutons,
                                                vous risqueriez d'attendre
                                                longtemps.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 107
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 10

/// AES 108 : WIND_CALC ///

Sert Ö demander les dimension d'une fenàtre, suivant que l'on dÇsire recevoir sa
dimension totale, ou l'espace de travail.
  Peut servir pour recevoir un "devis" sur une nouvelle fenàtre que l'on
voudrait crÇer, mais aussi afficher une image avec une copie raster bien pensÇe
(n'oubliez pas de gÇrer correctement les ascenseurs dans ce cas, car la
prÇcision n'est plus vraiment fiable si vous travaillez avec des images dont la
rÇsolution excäde 1000, la limite de dÇfinition de la position d'une cabine).

Paramätres : WORD : Code de commande
                    0 : Calcul de la taille de la fenàtre
                    1 : Calcul de la taille de l'espace de travail
             WORD : Attribut de la fenàtre Ö prendre en compte pour le calcul
                    BIT 0 : Barre de Titre
                    BIT 1 : Closer - Bouton au coin supÇrieur gauche pour
                            fermer la fenàtre
                    BIT 2 : Fuller - Bouton au coin supÇrieur droit pour ouvrir
                            la fenàtre sur tout le bureau
                    BIT 3 : Barre de dÇplacement - En fait, la Barre de Titre,
                            mais indique Ö l'AES que l'on dÇsire que cette
                            fenàtre soit dÇplaáable
                    BIT 4 : Info - La ligne d'informations juste sous la Barre
                            de Titre
                    BIT 5 : Sizer - Le bouton au coin infÇrieur droit pour
                            modifier la taille de la fenàtre
                    BIT 6 : UpArrow - La fläche vers le haut
                    BIT 7 : DnArrow - La fläche vers le bas
                    BIT 8 : VSlide - La "cabine" verticale, ainsi que
                            l'ascenseur
                    BIT 9 : LfArrow - La fläche vers la gauche
                    BIT A : RtArrow - La fläche vers la droite
                    BIT B : HSlide - La "cabine" horizontale, ainsi que le
                            couloir
             WORD : X
             WORD : Y
             WORD : Largeur
             WORD : Hauteur
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 108
             WORD : 200
Retour : D0.l = 0 si erreur, sinon pointeur vers un tableau contenant les
                dimensions demandÇes
                Structure du tableau : WORD 0 : X
                                       WORD 1 : Y
                                       WORD 2 : Largeur
                                       WORD 3 : Hauteur
Pile : 20

/// AES 109 : WIND_NEW ///

Sert Ö dÇtruire toutes les fenàtres. Träs pratique s'il s'agit de quitter le
programme, plus besoin de le faire Ö la main, pour chaque fenàtre.

Paramätres : LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 109
             WORD : 200
Retour : Aucun
Pile : 8

--- LIBRAIRIE RESOURCES ---

/// AES 110 : RSRC_LOAD ///

Sert Ö charger un fichier ressource prÇalablement crÇe avec un Çditeur de
ressources. Ce fichier contient toutes les informations pour exploiter les
Objets qu'il contient. Voici la structure d'une ressource :

> Structure Ressource

> Structure RscHead
  Le fichier ressource commence par un Header.
  WORD  0 : RSH_VRSN : Version de la ressource.
                       0 = Normale
                       4 = Etendue. Le fichier contient une extension situÇe Ö
                           sa fin, et composÇe des icones couleurs.
  WORD  1 :
  WORD  2 :
  WORD  3 :
  WORD  4 :
  WORD  5 :
  WORD  6 :
  WORD  7 :
  WORD  8 :
  WORD  9 :
  WORD  A :
  WORD  B :
  WORD  C :
  WORD  D :
  WORD  E :
  WORD  F :
  WORD 10 :
  WORD 11 :

> Structure RscData
  Les donnÇes normales d'un fichier ressource.

> Structure RscExt
  L'extension d'un fichier ressource contenant des icones couleurs.
  L'extension est composÇe de LONGs, chacun etant un "Slot".
  LONG 0 : FileSize : Longueur du fichier Ressource (permet de vÇrifier, un peu
                      comme une clÇ CRC).
  LONG 1 : ColorIc : OffSet vers la Structure CICON_Table
  LONG 2 : RÇservÇs, toujours Ö -1
  Les Slots suivant ne sont pas encore utilisÇs. S'il y en a, ils DOIVENT etres
  Ö -1.
  LONG x : Le dernier Slot est TOUJOURS Ö 0, et marque la fin de la Structure
           RscExt
  Une ressource Çtendue contient juste trois Slots: FileSize, ColorIc, et 0.

> Structure CICON_Table
  Cette structure est composÇe de pointeurs vide. Il y Ö autant de pointeur que
  de Stucture CICONBLK.
  Le dernier pointeur est TOUJOURS Ö -1.
  LONG 0 : 0
  LONG 1 : 0
  ...
  LONG x : -1, fin de la CICON_Table.

Paramätres : LONG : Adresse du nom du fichier
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 110
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 12

/// AES 111 : RSRC_FREE ///

Libäre la mÇmoire contenant la ressource chargÇe avec RSRC_LOAD. Attention
cependant, car si quitter un programme avec P_TERM(0) libäre toute la mÇmoire
rÇservÇe par M_(X)ALLOC, quitter le programme ne libäre pas la mÇmoire rÇservÇe
par RSRC_LOAD (quoique par la pratique, c'est pas si sur que áa, Ö moins qu'il
existe un buffer pour les ressources), donc il faut impÇrativement invoquer
RSRC_FREE (pas besoin de bougies, de statuettes et de sacrifices pour cela),
avant de quitter proprement l'application en cours.

Paramätres : LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 111
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 8

/// AES 112 : RSRC_GADDR ///

Sert Ö obtenir l'adresse d'un Objet, d'un arbre, d'une structure, ou de tout
autre chose ayant une relation (intime) avec les Objets du GEM.

Paramätres : WORD : Type d'Objet recherchÇ
                     0 : R_TREE : Adresse d'un Arbre
                                  Les Boites et les Menus font partis de cette
                                  grande famille.
                     1 : R_OBJECT : Adresse d'un Objet
                     2 : R_TEDINFO : Adresse d'une TedInfo
                     3 : R_ICONBLK : Adresse d'une IconBlk
                     4 : R_BITBLK : Adresse d'une BitBlk
                     5 : R_STRING : Adresse d'une String ou chaåne Free
                                    Les boites d'Alertes, par exemple
                     6 : R_IMAGEDATA : Adresse d'une Image Free
                     7 : R_OBSPEC : Adresse d'une Ob_Spec
                     8 : R_TEDTEXT : Adresse de l'adresse de TE_PTEXT
                     9 : R_TEDTMPLT : Adresse de l'adresse de TE_PTMPLT
                    10 : R_TEPVALID : Adresse de l'adresse de TE_PVALID
                    11 : R_IBPMASK : Adresse de l'adresse de IB_PMASK
                    12 : R_IBPDATA : Adresse de l'adresse de IB_PDATA
                    13 : R_IBPTEXT : Adresse de l'adresse de IB_PTEXT
                    14 : R_BIPDATA : Adresse de l'adresse de BI_PDATA
                    15 : R_FRSTR : Adresse de l'adresse d'une chaåne Free
                    16 : R_FRIMG : Adresse de l'adresse d'une image Free
             WORD : NumÇro d'ordre de l'Objet dans sa famille. C'est un coup de
                    force de "finesse" de la part de Digital Research, car il
                    n'existe pas de fonction pour dÇfinir ce numÇro. En fait, il
                    s'agit du numÇro d'apparition de ce type d'Objet dans le
                    fichier.
                      A vous donc de savoir combien vous en avez mis dans le
                    premier arbre, dans le deuxiäme, etc.. pour vous y
                    retrouver. Du coup, vous àtes largue-z, et pour trouver ce
                    fichus Objet, vous z'àtes perdu...
                      Disons, vous ne pouvez plus demander au GEM de le faire,
                    et cet Objet prend une position "absolue", car si l'on
                    modifie un temps soit peu le fichier ressource, et pas votre
                    programme, áa plante car les positions prÇalablement
                    dÇfinies ne correspondent plus. Cet Objet devra toujours
                    àtre oó il est, sans que ses attributs ne puissent àtres
                    modifiÇs (pas les graphiques, mais disons parental).
                      C'est pour cela que je suis en train de mettre au point
                    OBJC_SEARCH, une version plus conviviale de cette fonction.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 112
             WORD : 200
Retour : D0.l = 0 si erreur, sinon adresse recherchÇe
Pile : 12

/// AES 113 : RSRC_SADDR ///

Sert Ö changer d'adresse une structure. Attention Ö ne pas faire de bàtise, car
l'AES risque de ne pas apprÇcier s'il venait Ö rencontrer une structure non
standard, et Ö faire plein de petites bàtises, ce qui risque fort de vous
contrarier. Zut alors...
  SÇrieusement : Peut, par exemple, changer l'adresse d'un arbre, et le
rediriger vers un que vous venez de faire Ö la main. C'est träs utile pour les
crÇateur le ressource (vous savez, les "Ressource Construction Set").
  Faites cependant attention Ö que les adresses soient relogÇes en absolue, et
dÇsignent vÇritablement l'adresse d'un objet en mÇmoire. Ici, l'adressage
relatif au PC (quelque chose de similaire, Çvidement) est impossible (ce serait
vraiment, vraiment trop beau).

Paramätres : WORD : Type d'Objet Ö changer
                     0 : R_TREE : Arbre d'Objets
                     1 : R_OBJECT : Objet
                     2 : R_TEDINFO : TedInfo
                     3 : R_ICONBLK : IconBlk
                     4 : R_BITBLK : BitBlk
                     5 : R_STRING : String ou chaåne Free
                     6 : R_IMAGEDATA : Image Free
                     7 : R_OBSPEC : Ob_Spec
                     8 : R_TEDTEXT : Adresse de TE_PTEXT
                     9 : R_TEDTMPLT : Adresse de TE_PTMPLT
                    10 : R_TEPVALID : Adresse de TE_PVALID
                    11 : R_IBPMASK : Adresse de IB_PMASK
                    12 : R_IBPDATA : Adresse de IB_PDATA
                    13 : R_IBPTEXT : Adresse de IB_PTEXT
                    14 : R_BIPDATA : Adresse de BI_PDATA
                    15 : R_FRSTR : Adresse d'une chaåne Free
                    16 : R_FRIMG : Adresse d'une image Free
             WORD : NumÇro d'ordre de l'Objet dans sa famille.
             LONG : Adresse Ö fixer
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 113
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 16

/// AES 114 : RSRC_OBFIX ///

Sert Ö convertir les coordonnÇes et la taille d'un objet dont elles sont
exprimÇes en caractäres, en points. C'est utile, car dans ce cas, les Objets
changent de taille suivant la rÇsolution, et s'y adaptent.
Nez en moins, ce n'est pas tout Ö fait grÉce cela que je convertit les
coordonnÇes et tailles avec CONV_RSC2WK.
Lors d'un chargement d'une ressource, RSRC_LOAD s'en charge (c'est le cas de le
dire) dÇjÖ.

Paramätres : LONG : Adresse de l'arbre
             WORD : NumÇro de l'Objet Ö convertir
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 114
             WORD : 200
Retour : Aucun
Pile : 14

/// AES 115 : RSRC_RCFIX ///

  Sert Ö reloger un fichier ressource chargÇ en mÇmoire. Il procede Ö tout les
changements necessaires et opÇrÇs par RSRC_LOAD.

Paramätres : LONG : Header du fichier ressource en mÇmoire.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 115
             WORD : 200
Retour : D0.w = Toujours 1
Pile : 12

ATTENTION : Si une ressource est en train d'etre utilisÇe, n'oubliez pas de
            l'effacer avec RSRC_FREE avant d'utiliser RSRC_RCFIX.
--- LIBRAIRIE SHELL ---

  Ici, je vous conseille d'avancer tres prudement car vous travaillez avec
l'AES. Vous savez que le Bureau permet des choses tres interessantes. Mais dans
l'ombre, il utilise un fichier NewDesk.INF (ou Gem.INF sous multitos). Il peut
aussi lancer des applications, ce que l'on peut faire d'ici. OUBLIEZ P_EXEC du
GEMDOS, c'est beaucoup mieux ici, mais plus compliquÇ car plus complet...

/// AES 120 : SHEL_READ ///

Paramätres : LONG : Adresse de la commande
             LONG : Adresse des fonctions complÇmentaires
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 120
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 16

/// AES 121 : SHEL_WRITE ///

  Sert Ö demander Ö l'AES d'executer une autre application, et oó.

Paramätres : WORD : Mode d'action
                    0 = Lancer une application d'apräs son extension
                    1 = Lancer une application en prÇcisant son mode graphique
                    2 = RÇservÇ
                    3 = Lancer un accessoire
             WORD : Mode graphique de l'application
                    0 = Application TOS
                    1 = Application GEM
             WORD : Passer des paramätres
                    0 = NON
                    1 = OUI,
             LONG : Adresse de la commande
             LONG : Adresse de la Command-Tail
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 121
             WORD : 200
Retour : D0.w = 0 si erreur, sinon AP_ID de l'application executÇe.
Pile : 22

/// AES 122 : SHEL_GET ///

  Sert Ö lire le buffer interne de l'AES.

Paramätres : WORD : Nombre de caractäres Ö lire (pas plus de 1024 octets)
                    -1 = Demande la taille du buffer de l'AES.
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 122
             WORD : 200
Retour : D0.w = 0 si erreur, sinon le nombre d'octets lus ou la taille du
                buffer de l'AES
         D1.l = Adresse du buffer de l'AES
Pile : 10

/// AES 123 : SHEL_PUT ///

  Sert Ö Çcrire dans le buffer de l'AES.

Paramätres : LONG : Adresse du buffer de l'AES
             WORD : Nombre de caractäres Ö Çcrire (pas plus de 1024)
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 123
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 14

/// AES 124 : SHEL_FIND ///

(Pas documentÇ, mais implantÇ)

Paramätres : LONG : Adresse du nom du fichier
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 124
             WORD : 200
Retour : D0.w = 0 si erreur, sinon OK
Pile : 12

/// AES 125 : SHEL_ENVRN ///

(Pas documentÇ, mais implantÇ)

Paramätres : LONG : Adresse d'un tampon de 4 OCTETs pour recevoir un pointeur
             LONG : Adresse de la chaåne du critäre de recherche
             LONG : Adresse du buffer des variables (AES_PARAMS)
             WORD : 125
             WORD : 200
Retour : Aucun
Pile : 16

/// Le VDI, numÇro 115 ////////////////////////////////////////////////////////

/// La LineA //////////////////////////////////////////////////////////////////

  Bon, je vous donne cette partie Ö titre documentaire, apräs rÇflexion. Je me
trouvait devant le dilemme de vous instruire la dessus, ou pas, mais de toute
maniere, vous auriez fini par trouver la documents relatifs Ö la LineA.
  Ici, la Line A traite les instructions spÇciales dont cet OCTET de poids fort
est $A. Ces instructions provoquent dans l'ATARI des commandes graphiques
extràmement rapides car immÇdiatement interprÇtÇes par le processeur, mais
nÇanmoins font appels Ö une bibliothäque d'instructions "normale". Ces
instruction graphiques sont les plus utilisÇes. Y'en a juste 16, mais c'est
largement suffisant.
  Vu que ce sont des fonctions spÇcifique (en fait un vÇritable Op-Code), pour
appeler par exemple la premiäre fonction, il faut Çcrire dans votre programme

             dc.w            $A000

  Une fois la fonction exÇcutÇe, le programme poursuit Ö l'instruction suivante,
sans avoir besoin de restaurer la pile ou autre chose, vu que vous n'utilisez
pas de registres.

  Si j'hÇsitait Ö vous renseigner la dessus, c'est qu'ATARI, avant leur mort
(Dieu ait leurs ames), avait interdit l'utilisation de la LineA. Revenons sur
son passÇ. Au dÇbut de l'ATARI, il fallait des programmes pour que la machine
se vende. Or vous l'avez vu, le VDI n'est pas ce qu'il y Ö de plus pratique. De
plus, le rÇsultat dÇpend de la nature de la Station. La LineA Çtait plus rapide
Ö acceder, car juste via un OpCode, mais son execution etait plus rapide.
Cependant, elle connue plus de succes que les commandes VDI correspondantes (on
se demande pourquoi...). Cela fait, beaucoup de programmes utilisaient la
LineA, sans problemes. Arriva le TT, d'une conception radicalement differente,
qui apporta son nombre d'avantages, mais son lot d'incompatibilitÇ. La LineA en
fut un facteur importante. Non pas qu'elle s'averait inutile, elle remplissait
toujours son role, mais beaucoup avaient cour-circuitÇ le VDI, et sur TT, áa ne
marchais plus. Regardez donc comme le ST est un vrai TANK. On peu ecrire Ö la
limite de la mÇmoire sans plantage, on peut adresser des registres fantomes
(n'est ce pas Mad Max?), on peut se passer du VDI, etc...
  Or le TT, et son petit frere le Falcon030, sont de nature plus fragile. Si
ATARI a dÇcidÇ de laisser la LineA, c'est pour que les programmes qui
l'utilisent (et qui marchent exceptionnellement) puissent fonctionner. Mais il
aurait bien aimÇ que l'on programme proprement et correctement, n'ayant pas Ö
nous redire que le VDI existe, et s'il y avait evolution, ce serait lui qui
serait supportÇ, et pas la LineA.
  Bref, si jamais vous developpez un programme, utilisez le VDI. Si vous
desassemblez un programme, cela pourra vous aider pour comprendre.

Voici donc la description de chaque instruction :

/// A000 : LineA Init ///

Met la Line A en branle. Äa fait pas de bruit, ne mange pas de pain, mais Dieu,
que c'est pratique.
Retour : D0.l et A0 = Adresse des variables Line A. Ces variables forment un
                      gigantesque tableau contenant toutes (ou presque) les
                      informations sur tout ce qui peut àtre utile au systäme
                      d'exploitation. J'en voit dÇjÖ en train de se chauffer le
                      bout des doigts, en songeant dÇjÖ au Patch qui va
                      rÇvolutionner le monde (un patch pour Çliminer BG? Le trip
                      total, quoi...).
                        C'est d'ailleurs grÉce Ö ces variables que FalconScreen
                      Çtend la rÇsolution de l'Çcran (avec modification
                      judicieuse des registres du Videl (NdM: N'essayez pas sur
                      votre ST, il n'a pas ÇtÇ prÇvus pour, et un systeme
                      OverScan prendrait trop de temps)). Mais voyez plutìt :
OffSet Size Name         Data
  -906 LONG Cur_Font     Pointeur sur le Header de la Fonte utilisÇe
  -902                   RÇservÇ
     Ö
  -856 WORD M_Pos_HX     X du Point Chaud
  -854 WORD M_Pos_HY     Y du Point Chaud
  -852 WORD M_Planes     Mode d'Çcriture de la souris
                          1 = Normal
                         -1 = XOR
  -850 WORD M_Cdb_BG     Couleur du masque de la souris
  -848 WORD M_Cdb_FG     Couleur du pointeur de la souris
  -846 WORD Mask_Form    Les donnÇes de la souris
                         16 WORDs : Le masque
                         16 WORDs : Le pointeur
  -782 WORD Inq_Tab      Les 45 WORDs renvoyÇs par Vq_Extend (VDI )
  -692 WORD Dev_Tab      Les 45 WORDs renvoyÇs pas V_Opn(V)Wk (VDI 1-100)
  -602 WORD G_CurX       La coordonnÇe X actuelle de la souris
  -600 WORD G_CurY       Idem mais pour Y (hin hin...)
  -598 WORD M_Hid_Ct     Compteur du nombre de fois que vous avez demandez de
                         faire disparaåtre la souris
  -596 WORD Mouse_Bt     Etat des boutons de la souris (une souris Ö 16 boutons
                         est donc possible, et non, elle n'a pas de l'acnÇ).
  -594 WORD Req_Col      Les part VDI des couleurs RGB. Voyez Vq_Color (VDI )
                         sur 48 WORDs
  -498 WORD Siz_Tab      Sur 15 WORDs, les tailles pour les sorties texte
  -468 WORD              RÇservÇ
  -466 WORD              RÇservÇ
  -464 LONG Cur_Work     Pointeur vers les attributs de la station de travail
                         actuelle
  -460 LONG Def_Font     Pointeur vers le Header de la fonte par dÇfaut
  -456 LONG Font_Ring    4 LONGs qui forment la "Font_Queue", Ö l'image de la
                         VBL_Queue.
  -440 WORD Font_Count   Nombre de fonte dans Font_Ring
  -438                   RÇservÇ
     Ö
  -348 BYTE Cur_Ms_Stat  Statut de la souris
  -347 BYTE              RÇservÇ
  -346 WORD V_Hid_Cnt    Nombre de fois que l'on a demandÇ au curseur de
                         disparaåtre
  -344 WORD Cur_X        CoordonnÇe de la nouvelle position de la souris. Si
                         cette position est la màme que G_CurX et G_CurY, le
                         systäme d'exploitation ne se donne pas la peine de
                         retracer la souris, et ainsi vous gagnez quelques
                         cycles machines. Regardez l'oscillo d'un SoundTracker,
                         bougez la souris, et concluez...
  -342 WORD Cur_Y        Idem pour les Y.
  -340 BYTE Cur_Flag     Si diffÇrent de zÇro, la souris sera redessinÇe Ö la
                         prochaine VBL
  -339 BYTE Mouse_Flag   Si diffÇrent de zÇro, la souris est lÉchÇe sur le
                         Bureau, sinon elle est immobilisÇe
  -338 LONG              RÇservÇ
  -334 WORD V_Sav_X      CoordonnÇe X sauvegardÇe du curseur
  -332 WORD V_Sav_Y      CoordonnÇe Y sauvegardÇe du curseur
  -330 WORD Save_Len     Hauteur en point du morceau d'Çcran sauvegardÇ sous le
                         pointeur de la souris (en principe Çgal Ö la hauteur
                         de la souris)
  -328 LONG Save_Adr     Adresse du premier mot sauvegardÇ du morceau d'Çcran
                         sous la souris. En principe dÇpend de la forme de la
                         souris.
  -324 WORD Save_Stat
  -322 WORD Save_Area    128 WORDs composants le fond de l'Çcran avant que la
                         souris n'ait eu le temps de le salir de ses pixels
                         rebels et revendicateurs.
   -66 LONG User_Tim     Pointeur vers la routine utilisateur invoquÇe Ö chaque
                         battement de l'horloge. Voyez VEx_Time (VDI ).
   -62 LONG Next_Tim     Pointeur vers la routine de traáage du pointeur de la
                         souris.
   -58 LONG User_But     Pointeur vers la routine personnelle de gestion des
                         boutons de la souris.
   -54 LONG User_Cur     Pointeur vers la routine de traáage personnelle de la
                         souris.
   -50 LONG User_Mot     Pointeur vers la routine personnelle de gestion du
                         dÇplacement de la souris
   -46 WORD V_Cel_Ht     Hauteur en points de la cellule d'un caractäre
   -44 WORD V_Cel_MX     Nombre de caractäres par ligne-1
   -42 WORD V_Cel_MY     Nombre de lignes-1
   -40 WORD V_Cel_WR     Nombre d'OCTETs entre une ligne et la suivante
   -38 WORD V_Col_BG     Couleur du fond
   -36 WORD V_Col_FG     Couleur du premier plan
   -34 LONG V_Cur_Ad     Adresse du curseur Ö l'Çcran
   -30 WORD V_Cur_Of     Nombre d'OCTETs entre le dÇbut de l'Çcran et la
                         premiäre ligne de texte
   -28 WORD V_Cur_X      Position X du curseur
   -26 WORD V_Cur_Y      Position Y du curseur
   -24 BYTE V_Period     Nombre de VBL entre deux clignotement du curseur
   -23 BYTE V_Cur_Ct     Compte Ö rebours avant le clignotement du curseur
   -22 LONG V_FntAd      Pointeur vers les donnÇes de la fonte actuelle
   -18 WORD V_Fnt_Nd     Code ASCII maximum de la fonte
   -16 WORD V_Fnt_St     Code ASCII minimum de la fonte
   -14 WORD V_Fnt_Wd     Largeur de la fonte (en OCTETs)
   -12 WORD V_Rez_Hz     Nombre de points de l'Çcran actuel
   -10 LONG V_Off_Ad     Pointeur vers une tables d'OffSet de fontes
    -6 WORD              RÇservÇ
    -4 WORD V_Rez_Vt     Nombre de lignes de l'Çcran actuel
    -2 WORD Bytes_Ln     Largeur MFDB de l'Çcran
     0 WORD V_Planes     Nombre de plan de l'Çcran actuel
     2 WORD V_Lin_Wr     Nombre d'OCTETs par ligne
     4 LONG GEM_Contrl   Pointeur vers le tableau Contrl du GEM
     8 LONG GEM_IntIn    Pointeur vers le tableau IntIn du GEM
    12 LONG GEM_PtsIn    Pointeur vers le tableau PtsIn du GEM
    16 LONG GEM_IntOut   Pointeur vers le tableau IntOut du GEM
    20 LONG GEM_PtsOut   Pointeur vers le tableau PtsOut du GEM
    24 WORD _FG_BP_1
    26 WORD _FG_BP_2
    28 WORD _FG_BP_3
    30 WORD _FG_BP_4
    32 WORD _LstLin      -1 ici
    34 WORD _Ln_Mask     Motif de ligne
    36 WORD _Wrt_Mode    Mode d'Çcriture (Voyez VDI 32)
                         0 = Source
                         1 = Transparent
                         2 = XOR
                         3 = NOT Transparent
    38 WORD _X1          CoordonnÇe X du coin supÇrieur gauche
    40 WORD _Y1          CoordonnÇe Y du coin supÇrieur gauche
    42 WORD _X2          CoordonnÇe X du coin infÇrieur droit
    44 WORD _Y2          CoordonnÇe Y du coin infÇrieur droit
    46 LONG _PatPtr      Pointeur vers les donnÇes du motif de remplissage
    50 WORD _PatMsk      Pointeur vers le masque du motif de remplissage
    52 WORD _MultiFill   0 = Motif de remplissage sur un seul plan
                         1 = Motif de remplissage sur tous les plans
    54 WORD _Clip        0 = Pas de CLIPPING
                         1 = CLIPPING
    56 WORD _XMn_Clip    CoordonnÇe X du coin supÇrieur gauche du CLIPPING
    58 WORD _YMn_Clip    CoordonnÇe Y du coin supÇrieur gauche du CLIPPING
    60 WORD _XMx_Clip    CoordonnÇe X du coin infÇrieur droit du CLIPPING
    62 WORD _YMx_Clip    CoordonnÇe Y du coin infÇrieur droit du CLIPPING
    64 WORD _XAcc_DDA    ???
    66 WORD _DDA_Inc     Facteur d'Agrandissement/RÇduction
    68 WORD _T_SclSts    0 = RÇduction
                         1 = Agrandissement
    70 WORD _Mono_Status 0 = Fonte proportionnelle
                         1 = Fonte non proportionnelle
    72 WORD _SourceX     X du caractäre dans la fonte
    74 WORD _SourceY     Y du caractäre dans la fonte
    76 WORD _DestX       CoordonnÇe X du caractäre Ö l'Çcran
    78 WORD _DestY       CoordonnÇe Y du caractäre Ö l'Çcran
    80 WORD _DelX        Largeur du caractäre
    82 WORD _DelY        Hauteur du caractäre
    84 LONG _FBase       Pointeur vers le dÇbut des donnÇes de la fonte
    88 WORD _FWidth      Largeur de la fonte
    90 WORD _Style       Effets graphiques
    92 WORD _LiteMask    Masque pour l'Çcriture en clair
    94 WORD _SkewMask    Masque pour l'Çcriture en italique
    96 WORD _Weight      Nombre de BITs pour le gras
    98 WORD _R_Off       DÇplacement droit pour l'italique
   100 WORD _L_Off       DÇplacement gauche pour l'italique
   102 WORD _Scale       0 = Non
                         1 = Oui
   104 WORD _Chup        Angle de rotation du texte en dixiäme de degrÇ
   106 WORD _Text_FG     Couleur du texte
   108 LONG _ScrtChp     Adresse de la mÇmoire tampon pour la production des
                         effets graphiques sur le texte
   112 WORD _Scrpt2
   114 WORD _Text_BG     Couleur du fond pour le texte
   116 WORD _CopyTran    Si Ö 0, Copie Opaque (normale)
                              1, Copie Transparente (monochrome vers couleur)
   118 LONg _Fill_Abort  Pointeur vers une routine de test d'arràt pour le
                         remplissage. Il faut mettre 0 dans D0 pour faire
                         continuer le remplissage, sinon 1 pour qu'il s'arràte.

         A1 = Pointeur vers un tableau contenant les adresses des trois fontes
              systämes (6*6 icìnes, 8*8 Low Reso, 8*16 Hi Reso)
              Structure du tableau : LONG 0 : Adresse du Header de la fonte 6*6
                                     LONG 1 : Adresse du Header de la fonte 8*8
                                     LONG 2 : Adresse du Header de la fonte
                                              8*16
         A2 = Pointeur vers un tableau contenant les adresses des diffÇrentes
              routines Line A
              Structure du tableau : LONG 0 : Put Pixel
                                     LONG 1 : Get Pixel
                                     LONG 2 : Line
                                     LONG 3 : Horizontal Line
                                     LONG 4 : Filled Rectangle
                                     LONG 5 : Filled Polygon
                                     LONG 6 : BitBlt
                                     LONG 7 : TextBlt
                                     LONG 8 : Show Mouse
                                     LONG 9 : Hide Cursor
                                     LONG A : Transform Mouse
                                     LONG B : UnDraw Sprite
                                     LONG C : Draw Sprite
                                     LONG D : Copy Raster Form
                                     LONG E : Contour Fill

/// A001 : Put Pixel ///

Place un point d'une couleur donnÇe Ö l'Çcran.

Paramätres : X dans PtsIn0 (celui du GEM (voir variables LineA))
             Y dans PtsIn1 (Idem)
             Index de la couleur dans IntIn0 (Idem)
Retour : Aucun (sauf Ö l'Çcran)

/// A002 : Get Pixel ///

Permet d'obtenir la couleur d'un point.

Paramätres : X dans PtsIn0 (Celui du GEM)
             Y dans PtsIn1 (Idem)
Retour : D0.w = Index de couleur du point

/// A003 : Line ///

Permet de tracer une ligne. La fonction trace de la gauche vers la droite et de
haut en bas, donc attention Ö l'ordre des X et des Y.

Paramätres : X1 dans _X1
             Y1 dans _Y1
             X2 dans _X2
             Y2 dans _Y2
               Attention, car les lignes qui sortent de l'Çcran ne subissent pas
               de CLIPPING. En clair, la ligne est Çcrite jusqu'au bout. Pour
               faire cela, imaginez vous le jeu Asteroid, oó lorsque le vaisseau
               sort d'un cotÇ de l'Çcran, il rÇapparaåt de l'autre cotÇ.
                 Ici, c'est la màme chose. Une ligne de 0,0 Ö 639,639 sera
               affichÇe en fait de 0,0 Ö 479,479 et de 480,0 Ö 639,159.
                 Pour des lignes en couleur, il ne s'agit pas d'indiquer
               simplement l'index de couleur Ö utiliser, mais de dÇfinir
               directement les plans de BITs Ö afficher.
             Plan 0 dans _FG_BP_1
             Plan 1 dans _FG_BP_2
             Plan 2 dans _FG_BP_3
             Plan 3 dans _FG_BP_4
             Motif de la ligne dans _Ln_Mask
             Mode d'Çcriture dans _Wrt_Mod
               0 = Trace normalement la ligne
               1 = OR entre l'Çcran et le motif de la ligne
               2 = XOR entre l'Çcran et le motif de la ligne
               3 = XNOR entre l'Çcran et le motif de la ligne
             -1 dans _LstLin
Retour : Aucun (sauf bien Çvidement Ö l'Çcran)

/// A004 : Horizontal Line ///

Version optimisÇe de la prÇcÇdente, qui ne trace que des lignes horizontales.
C'est donc träs rapide. Cependant, cette fonction n'est pas plus simple que la
prÇcÇdente.

Paramätres : X1 dans _X1
             Y dans _Y1
             X2 dans _X2
             Y dans _Y2
             Plan 0 dans _FG_BP_1
             Plan 1 dans _FG_BP_2
             Plan 2 dans _FG_BP_3
             Plan 3 dans _FG_BP_4
             Motif de la ligne dans _Ln_Mask
             Mode d'Çcriture dans _Wrt_Mod
               0 = Trace normalement la ligne
               1 = OR entre l'Çcran et le motif de la ligne
               2 = XOR entre l'Çcran et le motif de la ligne
               3 = XNOR entre l'Çcran et le motif de la ligne
             Pointeur sur le motif de ligne Ö utiliser dans _PatPtr
             Masque du motif de la ligne dans _PatMsk
Retour : Aucun

/// A005 : Filled Rectangle ///

Sert Ö afficher un rectangle plein. Cette fonction est une dÇclinaison de la
prÇcÇdente, et en GROS, affiche une suite de lignes horizontales Ö l'Çcran. Màme
chose, l'ordre des coordonnÇes est important, donc haut Ö gauche d'abord, puis
bas Ö droite.

Paramätres : X1 dans _X1
             Y1 dans _Y1
             X2 dans _X2
             Y2 dans _Y2
             Pour les couleurs, c'est pareils.
             Plan 0 dans _FG_BP_1
             Plan 1 dans _FG_BP_2
             Plan 2 dans _FG_BP_3
             Plan 3 dans _FG_BP_4
             Mode d'Çcriture dans _Wrt_Mod
               0 = Trace normalement la ligne
               1 = OR entre l'Çcran et le motif de la ligne
               2 = XOR entre l'Çcran et le motif de la ligne
               3 = XNOR entre l'Çcran et le motif de la ligne
             Pointeur sur le motif de la ligne dans _PatPtr
             Pointeur vers le masque dans _PatMsk
             Flag du CLIPPING dans _Clip
               0 = Le rectangle est affichÇ tel quel, comme on le demande
               1 = Le CLIPPING dÇfinit est pris en compte
             X1 du CLIPPING dans _XMn_Clip
             Y1 du CLIPPING dans _YMn_Clip
             X2 du CLIPPING dans _XMx_Clip
             Y2 du CLIPPING dans _YMx_Clip
Retour : Aucun (sinon Ö l'Çcran, bien sur)

/// A006 : Filled Polygon ///

Trace un ensemble de lignes, et remplit les espaces.

Paramätres : Nombre de couple de coordonnÇes dans Contrl1
             Les diffÇrents couples dans PtsIn
               ATTENTION : Pour le premier couple, X dans PtsIn0 et Y dans
                           PtsIn1. Pour clore un polygone, terminer avec les
                           màmes premiäres coordonnÇes.
             Y de la ligne dans _Y1
             Plan 0 dans _FG_BP_1
             Plan 1 dans _FG_BP_2
             Plan 2 dans _FG_BP_3
             Plan 3 dans _FG_BP_4
             Mode d'Çcriture dans _Wrt_Mod
               0 = Trace normalement la ligne
               1 = OR entre l'Çcran et le motif de la ligne
               2 = XOR entre l'Çcran et le motif de la ligne
               3 = XNOR entre l'Çcran et le motif de la ligne
             Pointeur sur le motif de la ligne dans _PatPtr
             Pointeur vers le masque dans _PatMsk
             Flag du CLIPPING dans _Clip
               0 = Le rectangle est affichÇ tel quel, comme on le demande
               1 = Le CLIPPING dÇfinit est pris en compte
             X1 du CLIPPING dans _XMn_Clip
             Y1 du CLIPPING dans _YMn_Clip
             X2 du CLIPPING dans _XMx_Clip
             Y2 du CLIPPING dans _YMx_Clip
Retour : Aucun

/// A007 : BitBlt ///

Copie d'une zone de mÇmoire vers une autre, OBLIGATOIREMENT de la màme taille.
Si vous z'avez un Blitter, la fonction l'exploite.

Paramätres : Adresse d'une structure BitBlt dans A6 (c'est pas commun, hein?)

> Structure BitBlt
  WORD  0 : Largeur de la zone en points
  WORD  1 : Hauteur de la zone en points
  WORD  2 : Nombre de plans
  WORD  3 : Couleur du premier plan
  WORD  4 : Couleur de fond
  LONG  5 : OpÇration logique Ö effectuer. Les màmes que celle du Blitter.
               0 = Destination Ö 0 (utile pour effacer une zone de mÇmoire)
               1 = Source AND Destination
               2 = Source NAND Destination
               3 = Source (le plus frÇquent)
               4 = NOT Source AND Destination
               5 = Destination (quelle utilitÇ?)
               6 = Source XOR Destination
               7 = Source OR Destination
               8 = NOT Source NAND Destination
               9 = NOT Source XOR Destination
              10 = NOT Destination
              11 = Source NOR Destination
              12 = NOT Source
              13 = NOT Source OR Destination
              14 = NOT Source NOR Destination
              15 = Destination plein (tous les BITs Ö 1)
  WORD  7 : CoordonnÇe X du coin supÇrieur gauche du bloc source
            Si vous voulez copier un bloc entier, mettez 0
  WORD  8 : CoordonnÇe Y du coin supÇrieur gauche du bloc source
  LONG  9 : Adresse du bloc source
  WORD 11 : Nombre d' OCTETs entre deux WORD Ö copier. Normalement 2 pour une
            copie contiguâ.
  WORD 12 : Nombre d'OCTETs Ö sauter pour la ligne suivante.
  WORD 13 : Nombre d'OCTETs Ö sauter pour arriver sur le prochain plan. 2 il me
            semble.
  WORD 14 : CoordonnÇe X du coin supÇrieur gauche du bloc destination
  WORD 15 : CoordonnÇe Y du coin supÇrieur gauche du bloc destination
  LONG 16 : Adresse de la destination
  WORD 18 : Idem que WORD 11, mais pour la destination
  WORD 19 : Idem que WORD 12, mais toujours pour la destination
  WORD 20 : Idem que WORD 13, destination donc
  LONG 21 : Adresse de la "grille" Pattern. - Je comprend Pas -
  WORD 23 : Taille d'une ligne de la grille en OCTETs
  WORD 24 : Nombre d'OCTETs jusqu'au prochain plan de la grille
  WORD 25 : Hauteur de la grille
  WORD 26 : Masque (???)
       Ö
  WORD 37 :

Retour : Aucun

/// A008 : TextBlt ///

C'est LA fonction texte de l'ATARI. Elle est indÇpendante des fonctions BIOS,
mais vraiment supÇrieure. Cependant, les apports qu'elle offre, faudra les
prÇciser prÇcedemment, donc attendez vous Ö un gros boulot. Le mieux, entre
nous, est d'Çcrire une macro routine pour l'utiliser, avec un passage de
paramätres. De plus, on peut utiliser des fontes diffÇrentes, ce qui veut dire
casse tàte (un vrai de vrai, ici).

> Structure Font
  Structure d'une fonte normale.
  WORD  0 : Font Identifier : numÇro de la fonte
              1 = Fonte systäme
  WORD  1 : Taille de la fonte en points
  WORD  2 Ö 17 : Nom de la fonte
  WORD 18 : Code ASCII minimum des caractäres affichables (32 pour l'espace, en
            principe)
  WORD 19 : Code ASCII maximum des caractäres affichables
  WORD 20 : Distance entre la ligne de base et la ligne supÇrieure
  WORD 21 : Distance entre la ligne de base et la ligne ascendante
  WORD 22 : Distance entre la ligne de base et la demi ligne
  WORD 23 : Distance entre la ligne de base et la ligne descendante
  WORD 24 : Distance entre la ligne de base et la ligne infÇrieure
  WORD 25 : Largeur du caractäre le plus large de la fonte
  WORD 26 : Largeur de la cellule de caractäre la plus large de la fonte (en
            principe un point de plus que la largeur du caractäre le plus
            large)
  WORD 27 : DÇcalage gauche pour l'Çcriture en italique
  WORD 28 : DÇcalage droit pour l'Çcriture en italique
  WORD 29 : Nombre de BITs en plus Ö afficher pour obtenir une Çcriture en gras
  WORD 30 : Hauteur de la ligne pour l'Çcriture en UnderLine
  WORD 31 : Masque pour l'Çcriture en clair
  WORD 32 : Masque pour l'Çcriture en italique
  WORD 33 : Type de la fonte
            BIT 0 : Systeme
                      0 = Non
                      1 = Oui
            BIT 1 : Table de dÇcalage horizontale
                      0 = Non
                      1 = Oui
            BIT 2 : Byte Swap Flag - Format de la fonte
                      0 = Format INTEL (OCTET Bas - OCTET Haut (sens Z80))
                      1 = Format MOTOROLA (OCTET Haut - OCTET Bas (sens normal))
            BIT 3 : ProportionnalitÇ de la fonte
                      0 = Fonte Proportionnelle, la largeur des caractäres
                          dÇpend de leur taille
                      1 = Fonte Non-Proportionnelle, la largeur est la màme pour
                          tous les caractäres
  LONG 34 : Adresse de la table de dÇcalage horizontale
  LONG 36 : Adresse de la table de dÇcalage des caractäres
  LONG 38 : Adresse des donnÇes de la fonte
  WORD 40 : Taille d'une ligne de caractäre
  WORD 41 : Nombre de lignes de la fonte
  LONG 42 : Adresse de la prochaine fonte

Paramätres : Mode d'Çcriture dans _Wrt_Mode
             Index de couleur du texte dans _Text_Fg
             Index de couleur du fond du texte dans _Text_Bg
             Pointeur sur le dÇbut des donnÇes de la fonte dans _FBase
             Largeur de la fonte dans _FWidth
             X du caractäre dans la fonte dans _SourceX
             Y du caractäre dans la fonte dans _SourceY
             X du caractäre Ö l'Çcran dans _DestX
             Y du caractäre Ö l'Çcran dans _DestY
             Largeur du caractäre en points dans _DelX
             Hauteur du caractäre en points dans _DelY
             Effets Ö appliquer sur le texte dans _Style
             Masque pour l'Çcriture en clair dans _LiteMask
             Masque pour l'Çcriture en italique dans _SkewMask
             Facteur d'agrandissement du caractäre dans _Weight
             DÇplacement droit pour l'italique dans _R_Off
             DÇplacement gauche pour l'italique dans _L_Off
             Mode d'Agrandissement/RÇduction dans _Scale
             Accumulateur pour l'agrandissement dans _XACC_DDA
             Facteur d'agrandissement ou de rÇduction dans _DDA_Inc
             Direction de l'alignement dans _T_SclSts
             Angle de rotation dans _Chup
             Mode d'Çcriture fixe dans _Mono_Status
             Poiteur sur un buffer de travail pour l'application des effets
               dans _ScrtChp
             DÇplacement pour l'alignement dans _ScrtChp dans _ScrPt2
Retour : Aucun

/// A009 : Show Mouse ///

Fait apparaåtre la souris, màme sous TOS.

Paramätres : 0 dans Contrl1
             1 dans Contrl3
             Si vous mettez 0 dans IntIn0, le pointeur de la souris apparaåt
             immÇdiatement, sinon le compteur est pris en compte, et vous devez
             appeler cette fonction autant de fois qu'il Ö ÇtÇ demandÇ de faire
             disparaåtre le pointeur avant que celui ne rÇapparaisse. Kapito?
Retour : La souris dans les basques (La voisine perchÇe sur une chaise au
         milieu de la cuisine : Hiiiiiiiiiii!)

/// A00A : Hide Cursor ///

Demande de faire disparaåtre la souris.

Paramätres : Aucun
Retour : Clap, plus de souris. La voisine : "RhhhÉÉaa... Lovely" (Ω Gotlib)

/// A00B : Transform Mouse ///

Une nouvelle souris, une.

Paramätres : Couleur du masque (0 = Blanc en principe) dans IntIn3
             Couleur du pointeur (1 = Noir en principe) dans IntIn4
             Les donnÇes du masque dans IntIn5 Ö IntIn20
             Les donnÇes du pointeur dans IntIn21 Ö IntIn36
Retour : Votre souris change de tàte. Formidable, non? Essayez avec celle d'un
         ÇlÇphant, áa trompe ÇnormÇment.

/// A00C : Undraw Sprite ///

Dessine un Sprite de 16*16 pixels.

Paramätres : Adresse du buffer contenant le fond Ö replacer dans A2
Retour : Plus de Sprite

/// A00D : Draw Sprite ///

Dessine un Sprite monochrome.

Paramätres : CoordonnÇe X du Point Chaud du Sprite Ö afficher dans D0
             CoordonnÇe Y du Point Chaud du Sprite Ö afficher dans D1
             Pointeur vers la dÇfinition du Sprite dans A0
               WORD 0 : CoordonnÇe X du Point Chaud dans le Sprite
               WORD 1 : CoordonnÇe Y du Point Chaud dans le Sprite
               WORD 2 : Format
                        0 = VDI
                        1 = XOR (???)
                Suivant ce que contient les variables FG_Func et BG_Func, il se
                passe quelque chose de diffÇrent, suivant en plus le format
                choisit :


               WORD 3 : Couleur du masque
               WORD 4 : Couleur du Sprite

               puis 32 WORDs (2*16 lignes) oó les lignes du masque et du Sprite
               sont entrelacÇes

               WORD 5 : Ligne 0 du masque
               WORD 6 : Ligne 0 du Sprite
               WORD 7 : Ligne 1 du masque
               WORD 8 : Ligne 1 du Sprite
               ...
             Pointeur vers un buffer pour stocker le fond dans A2
               Ce buffer doit avoir une taille de 64 OCTETs pour chaque plan,
               plus 10 OCTETs
Retour : Un Sprite, Ö l'Çcran, en principe.

/// A00E : Copy Raster Form ///

Copie d'une zone de mÇmoire Ö mÇmoire. La diffÇrence avec BitBlt vient du fait
que cette fonction est un peu plus simple, et que l'on peut se passer des MFDB
si l'on ne prend que des morceaux d'Çcran.

ATTENTION : C'est une copie, donc le format Standard (PC, les OCTETs des pixels
            les uns Ö la suite des autres) n'est pas supportÇ.

Paramätres : Options de copie dans IntIn0
               BIT 3-0 : Suivant le mode de copie Opaque ou Transparente
                         Copie Opaque : 0 = Destination Ö 0
                                        1 = Source AND Destination
                                        2 = Source NAND Destination
                                        3 = Source (le plus frÇquent)
                                        4 = NOT Source AND Destination
                                        5 = Destination (quelle utilitÇ?)
                                        6 = Source XOR Destination
                                        7 = Source OR Destination
                                        8 = NOT Source NAND Destination
                                        9 = NOT Source XOR Destination
                                        10 = NOT Destination
                                        11 = Source NOR Destination
                                        12 = NOT Source
                                        13 = NOT Source OR Destination
                                        14 = NOT Source NOR Destination
                                        15 = Destination Ö "1"
                         Copie Transparente : 0 = Replace Mode
                                              1 = Transparent Mode
                                              2 = XOR Mode
                                              3 = Reverse Transparent Mode
               BIT 4 : Utilisation de la grille Pattern
                       0 = Non
                       1 = Oui
             Index des BIT Ö 1 pour la copie Transparente dans IntIn1
             Index des BIT Ö 0 pour la copie Transparente dans IntIn2
             X1 du coin supÇrieur gauche de la source dans PtsIn0
             Y1 du coin supÇrieur gauche de la source dans PtsIn1
             X2 du coin infÇrieur droit de la source dans PtsIn2
             Y2 du coin infÇrieur droit de la source dans PtsIn3
             X1 du coin supÇrieur gauche de la destination dans PtsIn4
             Y1 du coin supÇrieur gauche de la destination dans PtsIn5
             X2 du coin infÇrieur droit de la destination dans PtsIn6
             Y2 du coin infÇrieur droit de la destination dans PtsIn7
             Adresse du MFDB source dans Contrl7-8
               Si cette adresse est Ö 0, la Line A suppose que l'on lui demande
               poliment une opÇration sur l'Çcran en cours, et se passe donc de
               notre sympathique MFDB.
             Adresse du MFDB destination dans Contrl9-10
               Màme remarque.
             Pointeur de Pattern dans _PatPtr
             Mode du Pattern dans _MultiFill
               0 = Pattern monochrome
               1 = Pattern couleur
             Mode de copie dans _CopyTran
               0 = Copie Opaque, couleur vers couleur
               1 = Copie Transparente, monochrome vers couleur (les registres
                   IntIn1-2 sont pris en compte)
Retour : Aucun

/// A00F : Contour Fill ///

Remplit une surface avec une couleur.

Paramätres : X dans PtsIn0
             Y dans PtsIn1
             Index de couleur dans IntIn0
               Si cet index est positif, la couleur s'arràte de remplir
               lorsqu'elle rencontre le bord de l'Çcran, ou la couleur de màme
               index. Si par contre cet index est nÇgatif, la couleur s'arràte Ö
               toutes les couleurs diffÇrentes de celle oó elle Ö ÇtÇ dÇposÇe.
             Adresse d'une routine invoquÇe rÇguliärement dans _Fill_Abort
               On peut ainsi, avec un petit programme, demander d'arràter de
               remplir. Mais celui ci DOIT àtre le plus cours possible, ne pas
               faire appel au systäme
               d'exploitation, mais directement au HardWare. Terminez par un
               RTS.
Retour : Aucun (sauf l'Çcran)

/// Petite pause bien mÇritÇe /////////////////////////////////////////////////

  Alors, qu'en pensez vous? Pas mal pour un ATARI! Avouez que áa vous fout une
gifle de savoir le systeme d'exploitation aussi complet et puissant. Et oui,
meme si Digital Research s'est fait bouffÇ, áa ne les empechait pas d'etre de
vrai bon programmeur. C'est navrant que meilleur ne rime pas avec gagneur, et
qu'il n'y en ait que pour les ploucs. Bah, c'est peu etre mieux ainsi, vu qu'on
bosse dans l'ombre pour arriver oó on en est...
  Avant de voir les fonctions revolutionnaires (oh oh, le mot est faible!), une
petite rÇcrÇation, avec quelques documents indispensables pour bien programmer.

/// Les Cookies ///////////////////////////////////////////////////////////////

/// Le protocole XBRA /////////////////////////////////////////////////////////

/// Le protocole TubeGEM //////////////////////////////////////////////////////

/// Le ProgHeader et la BasePage //////////////////////////////////////////////

/// Le calme avant la tempete /////////////////////////////////////////////////

/// Etude du KA SSAV... ///////////////////////////////////////////////////////

  Et oui, on va terminer. Mais avant, on ne fait que commencer. Tout ce que
vous avez lu n'est rien comparÇ Ö ce que vous allez lire. C'est plus court,
mais tellement plus puissant. Ici, je ne vais pas vous expliquer d'avance ce
que vous allez trouver, je vous en laisse la surprise. Bonne route...

  Bon, vous avez vu que le GEM, c'est plein de Structures. Et bien, sadique que
je suis, je ne vais pas dÇroger Ö la regle, vous allez vous en prendre plein
les gencives. Ark ark ark...
  "Whaaa, c'est pas juste, t'avais jurÇ que tu n'utiliserais pas de tableaux,
t'es qu'un salaud!"...
HÇ, ho, cool. L'APPEL Ö SSAVCALL se fait bien en empilant, mais il est
tellement plus simple de travailler avec des tableaux, vous allez voir (et
comprendre pourquoi).
  Vous n'aurez rien Ö remplir, car il existe une fonction pour cela. Mais en
fait, c'est plus simple que vous ne le croyez, faites moi confiance. On se
retrouve Ö la sortie des artistes pour les autographes et les questions, d'ici
lÖ, je vous laisse admirer le spectacle...








